#+TITLE: FormulaPages
#+SETUPFILE: setup.org

The Master Plan for FormulaPages project.

* FormulaPages v1.0.0
  
  A modern, fast and comprehensive spreadsheet language for JavaScript and the Web.

  #+BEGIN_SRC js
    var wb = new workbook();
    var ws = wb.sheet();
    wb.nameRange("Values", "Sheet1!A1:A3");
    wb.nameRange("Total", "Sheet1!A4");
    wb.nameRange("Name", "Sheet1!B1");

    wb.set(ws, "A1:A4", [1,2,3, "=SUM(Values)"]);
    wb.set(ws, "B1", "World");

    assert( wb.run("Total = 6") );
    assert( wb.run("2=AVERAGE(Values)") );
    assert( wb.run('"Hello, World" = CONCATENATE("Hello, ", Name)') );
    assert( wb.run('"Hello, World" = "Hello, " & Name' ) );
  #+END_SRC
  
  
** Get Started
   
   Add the script to your webpage and start coding!
   
   #+BEGIN_SRC html
     <script type="text/javascript" src="formula.js"></src>
   #+END_SRC
   
** Runs on

   Designed to run in client and server-side JavaScript environments.
   
   - Browsers
     - In-Process
     - Web Workers
   - Module Loaders
     - Node modules
     - AMD
   - Server
     - Node.js
     - Rhino
      
* Workbook Model
  
  The *workbook Model*  defines the programming interface for interacting with a spreadsheet.

  The workbook provide a set of functions to modify state of the workbook and the data store in the worksheets.

** Create Workbook
   
  The model isolates the meta-data in the workbook and the data into the worksheets.

  Using the *new* operator a new workbook may be created. The workbook isolates the meta-data in the workbook; 
  and hold references to the worksheets which store only raw data in serializable JavaScript objects.
   
   #+BEGIN_SRC js
     var wb = new workbook();
   #+END_SRC
   
** Create Worksheet

   The *sheet* function creates a new object to store worksheet; and registers the sheet into the workbook.
   
   #+BEGIN_SRC js
     var wb = new workbook();
     var ws = wb.sheet(); 
     assert( ws, "should not be undefined" );
     assert( typeof ws === "object", "should be object" );
   #+END_SRC

   A worksheet's meta-data can be initalized by passing a *config* argument to the *sheet* function.

   #+BEGIN_SRC js
     var wb = new workbook();
     var ws = wb.sheet({ name: "ImportantSheet" }); 
     assert( wb.sheetNames[0] === "ImportantSheet", "should be first name in sheetNames array" );
     assert( wb.sheets[0] === ws, "should be first sheet in sheets array" );
   #+END_SRC

   Config options:

   | Name  | Purpose                                                                                               |
   |-------+-------------------------------------------------------------------------------------------------------|
   | name  | Text used to identify the worksheet. Defaults to automatic naming.                                    |
   | data  | The object which contains the data for the worksheet. Defaults to empty object.                       |
   | store | The format for the data stored in the worksheet. Defaults to store. Other options are column and row. |

** Populate Data

   The *set* function provides the interface to populate values and formulas into a sheet.

   There are 4 forms supported by this interface:

     1. set( sheetRef, address, value )
     2. set( sheetRef, row, col, value )
     3. set( sheetRef, range, values )
     4. set( sheetRef, batch_operations )
      
   The *sheetRef* may be the sheet index, sheet name or the sheet data object.
	
   #+BEGIN_SRC js
     var wb = new workbook();
     var ws = wb.sheet();

     // 1. set value by sheet index and address.
     wb.set( 0, "A1", 1.1 );
     assert( ws.A1 === 1.1 );

     wb.set( "Sheet1", "A1", 1.2 );
     assert( ws.A1 === 1.2 );

     wb.set( ws, "A1", 1.3 );
     assert( ws.A1 === 1.3 );

     // 2. set value by sheet index, row and column.
     wb.set( 0, 0, 0, 2 );
     wb.set( 0, 1, 0, 2 ); 
     assert( ws.A1 === 2 );
     assert( ws.A2 === 2 );

     // 3. set values by sheet name and range.
     wb.set( "Sheet1", "A1:A2", [3,3] );
     assert( ws.A1 === 3 );
     assert( ws.A2 === 3 );

     // 4. Perform batch operation by sheet name
     wb.set( "Sheet1", { A1: 8, B1: 8, C1: "=A1+B1" } );
     assert( ws.A1 === 8 );
     assert( ws.B1 === 8 );
     assert( ws.C1 === 16 );

   #+END_SRC

** Access Values

   The *get* function provides a generic high-level interface to access cell or range objects.

   #+BEGIN_SRC js
     var wb = new workbook();
     var ws = wb.sheet();

     wb.set(0, "A1", "Hello, World");

     // access cell object
     assert( workbook.fn.ISCELL(wb.get("Sheet1", "A1")) );
     assert( wb.get("Sheet1", "A1").value() === "Hello, World" );

     // access range object
     assert( workbook.fn.ISRANGE( wb.get("Sheet1", "A1:D10") ) );
   #+END_SRC

   The *getValue* function provides a generic low-level interface to access a cell's value in a worksheet.

   Syntax:
   getValue(sheetIndex, row, col)

   #+BEGIN_SRC js
     var wb = new workbook();
     var ws = wb.sheet();

     wb.set(0, "A1", "Hello, World");

     assert( wb.getValue(0, 0, 0) === "Hello, World" );
   #+END_SRC

   Alternatively, the data may be accessed directly through the worksheet data object.

   The default storage backend is the *object* store. This stores the values in key/value pairs where
   the key is the column letter combined with the row (e.g A1).

   #+BEGIN_SRC js
     var wb = new workbook();
     var ws = wb.sheet();

     wb.set(0, "A1", "Hello, World");

     assert( ws.A1 === "Hello, World" );

   #+END_SRC

   Alternatively, you may store your values in the *row* store which organizes the values
   into an array of array where the inner arrays are the rows.

   #+BEGIN_SRC js
     var wb = new workbook();
     var ws = wb.sheet({ store: 'row' });

     wb.set(0, "B3", "Hello, World");
     assert( ws[2][1] === "Hello, World" );
   #+END_SRC

   Or, the *column store* which is like the row store but with the columns as the inner array.

   #+BEGIN_SRC js
     var wb = new workbook();
     var ws = wb.sheet({ store: 'col' });

     wb.set(0, "B3", "Hello, World");
     assert( ws[1][2] === "Hello, World" );
   #+END_SRC
   
** Run Formula
   
   The *workbook.run* function accepts a formula and reduces to a value.
   
   #+BEGIN_SRC js
     assert( "Yes" === workbook.run('IF(TRUE, "Yes", "No") ') );
   #+END_SRC

   Often, you may wish to run a formula within a particular context. Typically, this context is a sheet; which only store the values of the cells.

   #+BEGIN_SRC js
     var wb = new workbook();
     var ws = wb.sheet();
     wb.set(ws, "A1", "Hello, Sheets");
     wb.run( ws, "=A1" );
   #+END_SRC

   In this software; sheets are POJO. They are serializable to JSON because because they only store data; without methods or circular references.

   #+BEGIN_SRC js
     var wb = new workbook();
     var ws = wb.sheet( { name: "MySheet", data: { A1: 1 } } );
     assert( wb.run(ws, "1=A1"), "A1 should be 1");
     assert( ws.A1 === 1, "ws.A1 should be 1");
   #+END_SRC

** Name Range

   The *nameRange* function is used to name a cell or range.
   
   #+BEGIN_SRC js
     var wb = new workbook();
     var ws = wb.sheet(); // Auto name is Sheet1
     wb.nameRange("Values", "Sheet1!A1:A3");
     wb.nameRange("Total", "Sheet1!B1");

     wb.set( ws, "Values", [5, 3, 2] );
     wb.set( ws, "Total", "=SUM(Values)" );

     assert( +wb.run("Total") == 10, "Total should be 10");
   #+END_SRC

** Handle Events

   The *workbook.on* function registers a callback for events.
   
   | Event Name                                       | Operation                                                            |
   |--------------------------------------------------+----------------------------------------------------------------------|
   | set(sheetName, row, col, oldValue, newValue)     | Callback immediately after cell is set to a new value or a formula   |
   | updated(sheetName, row, col, oldValue, newValue) | Callback immediately after cell is updated when formula recalculates |
   
   #+BEGIN_SRC js
     var wb = new workbook();
     var sheet = wb.sheet();
     var set_count = 0;
     var update_count = 0;

     wb.on("set", function(sheetName, row, col, oldValue, newValue) {
         set_count++;
     });

     wb.on("updated", function(sheetName, row, col, oldValue, newValue) {
         update_count++;
     });

     wb.set(sheet, "A1", 2);
     wb.set(sheet, "A2", 2);
     wb.set(sheet, "A3", "=SUM(A1:A2)");

     assert( +wb.get(sheet, "A3") === 4, "A3 should be 4");

     wb.set(0, "A2", 20);

     assert( +wb.get(sheet, "A3") === 22, "A3 should be 22");

     assert( set_count === 4, "Set count should be 4" );
     assert( update_count === 1, "Update count should be 1" );
   #+END_SRC
   
** TODO Filtering Rows

   How will a user filter rows?

** TODO Sorting Rows

   How will a user re-order the rows?

** TODO Reordering Rows

   How would a user swap two rows?

** TODO Moving Columns

   How would a user swap two columns?
   
** Compile Formula
   
   The *workbook.compile* function compiles the formula into a JavaScript function, JavaScript code or a list of precendents.
   
   #+BEGIN_SRC js
     assert( 4 === workbook.compile("2+2")() );
   #+END_SRC

   The compiler support four modes:

   | mode | description           |
   |------+-----------------------|
   |    1 | JS Function (Default) |
   |    2 | JavaScript code       |
   |    3 | Function code         |
   |    4 | Array of Precedents   |

   #+BEGIN_SRC js
     assert( "workbook.fn.ADD(2,2)" === workbook.compile("2+2", 2) );
   #+END_SRC

   #+BEGIN_SRC js
     assert( "// formula: 2+2\nfunction(context) {\n  return workbook.fn.ADD(2,2);\n}" === workbook.compile("2+2", 3) );
   #+END_SRC

   #+BEGIN_SRC js
     var precedents =  workbook.compile("SubTotal+Taxes", 4);
     assert( precedents.length = 2 );   
     assert( precedents[0].type    === "value" );
     assert( precedents[0].subtype === "variable" );
     assert( precedents[0].value   === "SubTotal" );

     assert( precedents[1].type    === "value" );
     assert( precedents[1].subtype === "variable" );
     assert( precedents[1].value   === "Taxes" );  
   #+END_SRC

** Parse Formula
   
   The *workbook.parse* function accepts a formula and returns a syntax tree.
   
   #+BEGIN_SRC js
     var ast = workbook.parse("1+2");

     assert( ast.type === "operator" );
     assert( ast.subtype === "infix-add" );
     assert( ast.operands.length === 2 );

     assert( ast.operands[0].type === "value" );
     assert( ast.operands[1].type === "value" );

     assert( ast.operands[0].subtype === "number" );
     assert( ast.operands[1].subtype === "number" );

     assert( ast.operands[0].value === 1 );
     assert( ast.operands[1].value === 2 );
   #+END_SRC
   
** Get Column Index
   
   The *workbook.toColumnIndex* converts a column name (e.g AA) into the column index (e.g 26).
   
   #+BEGIN_SRC js
     assert(26 === workbook.toColumnIndex("AA") );
   #+END_SRC
   
** Get Column Letters
   
   The *workbook.toColumn* function converts column index into the column letters (e.g AA).
   
   #+BEGIN_SRC js
     assert("AA" === workbook.toColumn(26) );
   #+END_SRC

** TODO Solver

   How would a user solve a problem by specifying the desired outcome.

** TODO Pivot

   How will a user pivot data?

** TODO Set formula on range

   How would a user set a formula on a range instead of a cell.
   
* Range Model
  
  The range API gives you access to blocks of cells within a [[*Worksheet Model][worksheet]].
  
  The range is defined by the top left and bottom right cells.
  
** Get cells
   
   The *cells* method returns the flattened list of cells included in the range.
   
   #+BEGIN_SRC js
     var wb = new workbook();
     var ws = wb.sheet()
     var r = wb.range(ws, "A1", "A10")
     var cells = r.cells(2);

     assert( cells[0] === "A1", "First item should be A1");
     assert( cells[1] === "A2", "Second item should be A2");
   #+END_SRC
   
** Check if cells in range
   
   To test if a cell is included in a range use the *hit* method.
   
   #+BEGIN_SRC js
     var wb = new workbook();
     var ws = wb.sheet()
     var r = wb.range(ws, "A1", "A10");

     assert( workbook.hit(r, "A1"), "A1 should be hit." );
     assert( workbook.hit(r, "A5"), "A5 should be hit." );
     assert( workbook.hit(r, "A10"), "A10 should be hit." );
     assert( !workbook.hit(r, "A11"), "A10 should not be hit." );
     assert( !workbook.hit(r, "B1"), "B1 should not be hit." );
   #+END_SRC

* Cell Model
  
  The cells API let you interact with item in a worksheet.

  The properties available are:
  
  1. worksheet
  2. addr
  3. name
  4. row
  5. column
  6. colIndex
  7. rowIndex
  
** Get Cell

  #+BEGIN_SRC js
    var wb = new workbook();
    var ws = wb.sheet();
    assert(isNaN(+wb.cell(ws, "A1")), "Should be blank");
    wb.set(ws, "A1", 1);
    assert(1 === +wb.cell(ws, "A1"), "Should be 1");
  #+END_SRC

* API Examples							   :noexport:
** SUM up list of numbers
   
   Sum up a list of numbers using arrays and worksheets.
   
   #+BEGIN_SRC js
     // sum first 7 numbers in fibonacci sequence
     assert( workbook.run("=SUM({0,1,1,2,3,5,8})")  == 20, "Should be 20");

     // sum up a list loaded into a worksheet
     var wb = new workbook();
     var ws = wb.sheet()
     ws.set([
	 [1],
	 [1],
	 [2],
	 [3],
	 [5],
	 [8]
     ]);

     assert( ws.run("SUM(A1:A6)", "Should be 20 also") );
   #+END_SRC
   
** Automatic Updates
   
   Use *Worksheet.on* to register event handlers when cells change.
   
   #+BEGIN_SRC js
     var wb = new workbook();
     var sheet = wb.sheet();

     wb.set(sheet, {
         A1: 0,
         A2: 50,
         A3: 50,
         A4: "=SUM(A1:A3)"
     });

     // 0 + 50 + 50 = 100
     assert(wb.run(sheet, '+A4=100'), "A4 is not 100") 

     // 50 + 50 + 50 = 150
     sheet.set("A1", 50);

     assert(wb.run(sheet, '+A4=150'), "A4 is not 150") 
   #+END_SRC
   
** Listen to Changes
   
   Listen to events with *[[*Worksheets.on][workbook.on]]* and log to the console.
   
   #+BEGIN_SRC js
     var wb = new workbook();
     var sheet = wb.sheet();

     wb.on("set", function(ws, cell, newValue, oldValue) {
         display(cell + " changed from \"" + oldValue +
                 "\" to " + newValue + '"');
     });

     wb.on("updated", function(ws, cell, newValue, oldValue) {
         display(cell + " updated from \"" + oldValue +
                 "\" to \"" + newValue + "\"" );
     });

     // populate sheet
     wb.set(sheet, {
         A1: 10,
         B1: 20,
         C1: '=A1+B1',
         D1: '=C1 * 50%',
         E1: '=D1 * 50%',
         F1: '=MIN(D1 * 25%, 10)'
     });

     // max value is 10
     sheet.set("A1", 100);

   #+END_SRC
   
** Reference external cells
   
   Automatic updates works with multiple sheets in a workbook.
   
   #+BEGIN_SRC js
     var wb = new workbook();
     var SheetA = wb.sheet({ name: "SheetA" });

     SheetA.set("A1", 1);

     SheetA.set("A2", "=A1 * 10");

     var SheetB = wb.sheet({ name: "SheetB" });

     SheetB.set("A2", "=SheetA!A2");

     // 10 = 1 * 10
     assert(+SheetB.get("A2") === 10, "Should be 10");

     // Cross sheet updates!
     SheetA.set("A1", 2); 

     // 20 = 2 * 10
     assert( 20 === +SheetB.get("A2"), "Should be 20");

     var SheetC = wb.sheet({ name: "Sheet C" });

     SheetC.set("A1", "=SheetB!A2*4");

     // 20 * 4
     assert(80 === +SheetC.get("A1"), "Should be 80");

     var SheetD = wb.sheet({ name: "SheetD" });

     // 80 + 20
     SheetD.set("A1", "='Sheet C'!A1 + SheetB!A2");

     assert(+SheetD.get("A1") === 100, "Should be 100");


     SheetA.set("A1", 100); 

     // 1000 = 100 * 10
     assert(1000 === +SheetB.get("A2"), "Should be 1000");

     // 1000 * 4
     assert( 4000 === +SheetC.get("A1"), "Should be 4000");

     // 4000 + 1000
     assert( 5000 === +SheetD.get("A1"), "Should be 5000");

   #+END_SRC
   
** Column Store
   
   The *ColumnStore* stores values in arrays indexed by col and then row.
   
   #+BEGIN_SRC js
     // Loading the data into the column or row store is the fastest way
     // to put data into your worksheet. It is *assigned by reference*.
     var wb = new workbook();
     var ws = wb.sheet({
	 name: "ColumnStoreExampleSheet",
	 store: 'column',
	 data: [ 
	     ['A1', 'A2', 'A3'], // 1st column
	     ['B1', 'B2', 'B3'], // 2nd column
	     ['C1', 'C2', 'C3']  // 3rd column
	 ]
     });

     display(ws.get('A1'));
     display(ws.get('A2'));
     display(ws.get('B2'));
     display(ws.get('B3'));

   #+END_SRC
   
** Row Store
   
   The *RowStore* is the inverse of the *ColumnStore*; and probably the most common.
   
   #+BEGIN_SRC js
     // Loading the data into the column or row store is the fastest way
     // to put data into your worksheet. It is *assigned by reference*.
     var wb = new workbook();
     var ws = wb.sheet({
	 name: "RowStoreExampleSheet",
	 store: 'row',
	 data: [ 
	     ['A1', 'B1', 'C1'], // 1st row
	     ['A2', 'B2', 'C2'], // 2nd row
	     ['A3', 'B3', 'C3']  // 3rd row
	 ]
     });

     display(ws.get('A1'));
     display(ws.get('A2'));
     display(ws.get('B2'));
     display(ws.get('B3'));
   #+END_SRC
   
** Decision Table with OFFSET
   
   Decision tables are easy with this offset and match combo.
   
   #+BEGIN_SRC js
     var wb = new workbook("CustomPricingModel");
     var pricing_table = wb.sheet({ name: "PriceTable" });
     var customer_price = wb.sheet({ name: "CustomerPrice" });

     pricing_table.set(
	 [
	     ["Programs:", 100,                                      200,                      300,                      400],
	     ["Rule1",     "=CustomerPrice!A1", "=CustomerPrice!A1*0.95",  "=CustomerPrice!A1*0.8", "=CustomerPrice!A1*0.78"],
	     ["Rule2",     "=CustomerPrice!A1", "=CustomerPrice!A1*0.90", "=CustomerPrice!A1*0.85", "=CustomerPrice!A1*0.82"]
	 ]
     );


     // order total before discount
     customer_price.set("A1", "42"); 
     // customer program
     customer_price.set("A2", "100"); 

     // lookup discounted price by matching the position of 100 in the
     // decision table and moving 0 column to the right of PriceTable!A2.
     customer_price.set("A3", '=OFFSET(PriceTable!A2, 0, MATCH(A2, PriceTable!B1:E1, 0))');

     assert( +customer_price.get("A3") === 42, "Price should be 42");

     customer_price.set("A2", "200");

     // Now the discounted price is found 1 column to the right.
     assert( +customer_price.get("A3") === (42*0.95), "Price should be " + (42*0.95));

     // Now the discounted price is found 2 columns to the right.
     customer_price.set("A2", "300");

     assert( +customer_price.get("A3") === (42*0.8), "Price should be " + (42*0.8));

     customer_price.set("A2", "400");

     assert( +customer_price.get("A3") === (42*0.78), "Price should be " + (42*0.78));

     customer_price.set("A2", "foo");

     assert( customer_price.run("A3 = NA()"), "Error should be #N/A");

   #+END_SRC
   
** Create a Worksheet 
   
   Setup a container for your data and access with ranges (e.g. A1:B4).
   
   #+BEGIN_SRC js
     var wb = new workbook();
     // Initialize a worksheet using an array for each row and an array to keep rows.
     var sheet = wb.sheet({ workbook: wb, store: 'row', data: [
	 ["Category", "Total"],  // A1 and B1
	 ["Shoes", 500],         // A2 and B2
	 ["Shirts", 1000],       // A3 and B3
	 ["Pants", 1200]         // A4 and B4
     ]});

     // Get the 2nd column, 3rd row should return 1000
     assert( sheet.get("B3") === sheet.get(1,2), "B3 should be 1,2" );

     assert( "Category" === sheet.get("A1"), "A1 should be category" );

     assert( "Shoes" === sheet.get("A", 2), "A2" );

     assert(JSON.stringify(sheet.get("A1:B4").values()) ===
	    '[["Category","Total"],["Shoes",500],["Shirts",1000],["Pants",1200]]',
	    "range is incorrect");

   #+END_SRC

* Formulas
  
  The formulas use the same syntax and functions found in most spreadsheet software. 

** Technical Notes						   :noexport:

  Under the covers the formulas are compiled to JavaScript which depend on functions loaded
  on the page. The library looks for functions in the workbook.fn namespace and if not found then
  in the root object (e.g. window).
  
** Constants
   
   - TRUE
   - FALSE
     
** Prefix Operators
   
   A prefix operator is immediately to the left of the operand.
   
   |----------+--------------+---------------------------------------------------------------+--------------|
   | operator | Token Name   | Operation Performed                                           | Supported    |
   |----------+--------------+---------------------------------------------------------------+--------------|
   | -        | prefix-minus | Negates operand; converts positive to negative and vice versa | Yes          |
   | +        | prefix-plus  | Converts operand to number                                    | Yes          |
   | $        |              | Next component of an A1 reference is absolute                 | No / Ignores |
   |----------+--------------+---------------------------------------------------------------+--------------|
   
** Inflix Operators
   
   An inflix operator is between two operands. The operands are called the rhs and lhs for right hand side and left hand side, respectively.
   
   |----------+----------------+-----------------------------------+-----------|
   | Operator | Token Name     | Operation Performed               | Supported |
   |----------+----------------+-----------------------------------+-----------|
   | +        | infix-plus     | addition                          | Yes       |
   | -        | infix-minus    | subtraction                       | Yes       |
   | *        | infix-multiply | multiplication                    | Yes       |
   | ^        | infix-power    | exponentiation                    | Yes       |
   | =        | infix-eq       | is equal to                       | Yes       |
   | <>       | infix-ne       | is not equal to                   | Yes       |
   | >        | infix-gt       | is greater than                   | Yes       |
   | <        | infix-lt       | is less than                      | Yes       |
   | >=       | infix-gte      | is greater than or equal to       | Yes       |
   | <=       | infix-lte      | is less than or equal to          | Yes       |
   | &        | infix-concat   | concatentation of strings         | Yes       |
   | \w       |                | reference intersection            | No        |
   | ,        |                | reference union                   | Yes       |
   | :        |                | reference range                   | Yes       |
   | !        |                | separate worksheet from reference | Yes       |
   |----------+----------------+-----------------------------------+-----------|
   
** Postfix Operators
   
   A postfix operator is immediate to the right side of the operand.
   
   |----------+------------------------+-----------|
   | Operator | Operation              | Supported |
   |----------+------------------------+-----------|
   | %        | Divides operand by 100 | Yes       |
   |----------+------------------------+-----------|
   
** Matchfix Operators
   
   A matchfix operator specifies the start and end of a logical grouping.
   
   |-----------+------+-------+-----------------------------------------------------------------|
   | Supported | left | right | Operation                                                       |
   |-----------+------+-------+-----------------------------------------------------------------|
   | Yes       | "    | "     | string constant                                                 |
   | Yes       | {    | }     | array constant                                                  |
   | Yes       | (    | )     | arithmetic grouping or function arguments or reference grouping |
   | Yes       | '    | '     | grouping worksheet name                                         |
   | No        | [    | ]     | grouping workbook name (external reference)                     |
   | No        | [    | ]     | Relative reference in R1C1 style                                |
   |-----------+------+-------+-----------------------------------------------------------------|
   
** Operator Precedence
   
   If you combine several different operators into the same formula then the operations
   are based on the precedence of each operator.
   
   This table describe the order in which the operation are performed with the operations
   performed first on the top.
   
   |-------------------------------+---------------------|
   | Operator                      | Description         |
   |-------------------------------+---------------------|
   | -                             | Negation (as in –1) |
   | %                             | Percent             |
   | ^                             | Power Function      |
   | * and /                       | Multiply and Divide |
   | + and -                       | Add and Subtract    |
   | &                             | Combine two strings |
   | < and > and <=  and >= and <> | Comparision         |
   |-------------------------------+---------------------|
   
** Change Order with Grouping
   
   Parentheses can be used to change the order in which operation are performed. For example,
   the formula below results in 15. 5*2 is multipled to result in 10. The result is then added
   to 5.
   
   #+BEGIN_EXAMPLE
     =5+5*2
   #+END_EXAMPLE
   
   To override the default order you can group together expression. For example below the formula
   results in 20 because 5+5 is added together and multipled by 2.
   
   #+BEGIN_EXAMPLE
     =(5+5)*2   
   #+END_EXAMPLE

** Calculation Errors

   The calculation errors categorize problem found in formulas.

   The errors supported by the system are:
   
   #+NAME: ErrorTypes
   |---------+---------------|
   | code    | text          |
   |---------+---------------|
   | nil     | #NULL!        |
   | div0    | #DIV/0!       |
   | value   | #VALUE?       |
   | ref     | #REF!         |
   | name    | #NAME?        |
   | num     | @NUM!         |
   | na      | #N/A          |
   | error   | #ERROR!       |
   | data    | #GETTING_DATA |
   | missing | #MISSING      |
   | unknown | #UNKNOWN      |
   |---------+---------------|

   #+NAME: CalcErrors
   #+Begin_src js :exports none
     // Define the error system
     var error = {};

     function CalcError(message) {
         this.message = message;
     }

     CalcError.prototype = new Error; 

     CalcError.prototype.toString = function() {
         return this.message;
     }

     error.nil = new CalcError('#NULL!');
     error.div0 = new CalcError('#DIV/0!');
     error.value = new CalcError('#VALUE?');
     error.ref = new CalcError('#REF!');
     error.name = new CalcError('#NAME?');
     error.num = new CalcError('#NUM!');
     error.na = new CalcError('#N/A');
     error.error = new CalcError('#ERROR!');
     error.data = new CalcError('#GETTING_DATA');
     error.missing = new CalcError('#MISSING');
     error.unknown = new CalcError('#UNKNOWN');

   #+END_SRC
    
* Logical
  :PROPERTIES: 
  :id:     logical
  :END:
** AND
   
   Returns TRUE if all arguments evaluate to TRUE; otherwise returns FALSE.
   
   #+BEGIN_EXAMPLE
    AND(TRUE, FALSE) = FALSE
   #+END_EXAMPLE
   
   #+BEGIN_EXAMPLE
   AND(1, TRUE) = TRUE
   #+END_EXAMPLE

** OR
   
   Returns TRUE if any argument is true.
   
   #+BEGIN_EXAMPLE
   OR(TRUE, FALSE)
   #+END_EXAMPLE
   
   #+BEGIN_EXAMPLE
   OR(FALSE, FALSE) = FALSE
   #+END_EXAMPLE

** NOT
   
   Returns TRUE when FALSE and FALSE when TRUE;
   
   #+BEGIN_EXAMPLE
   NOT(FALSE)
   #+END_EXAMPLE
   
   #+BEGIN_EXAMPLE
   NOT(TRUE) = FALSE
   #+END_EXAMPLE

** IF
   
   Returns true_value if a condition you specify evaluates to TRUE and false_value if it evaluates to FALSE.
   
   #+BEGIN_EXAMPLE
   IF(1,"Yes", "No") = "Yes"
   #+END_EXAMPLE
   
** IFERROR
   
   Returns a value you specify if a formula evaluates to an error; otherwise, 
   returns the result of the formula.
   
   #+BEGIN_EXAMPLE
   IFERROR(1/0, "Error") = "Error"
   #+END_EXAMPLE
   
** IFNA
   
   Returns the value you specify if the formula returns the #N/A error value; otherwise returns the result of the formula.
   
   #+BEGIN_EXAMPLE
   =IFNA(NA(), TRUE, FALSE)
   #+END_EXAMPLE
   
** SWITCH
   
   Evaluates an expression against a list of values and returns the matching result.
   
   #+BEGIN_EXAMPLE
   SWITCH(1, 1, "January", 2, "February", 3,
   "March", 4, "April", 5, "May", 6, "June", 7, "July", 8,
   "August", 9, "September", 10, "October", 11, "November", 12,
   "December", "Unknown month number") = "January"
   #+END_EXAMPLE
   
   #+BEGIN_EXAMPLE
   SWITCH(1, 1, "Good", 2, "OK", 3, "Bad") = "Good"
   #+END_EXAMPLE
   
   #+BEGIN_EXAMPLE
   SWITCH(3, 1, "Good", 2, "OK", 3, "Bad") = "Bad"
   #+END_EXAMPLE
   
** CHOOSE
   
   Choose a value from a list.
   
   #+BEGIN_EXAMPLE
   CHOOSE(2, "Hello", "World") = "World"
   #+END_EXAMPLE
   
   #+BEGIN_EXAMPLE
   CHOOSE(3, "One", "Two", "Three") = "Three"
   #+END_EXAMPLE
   
** XOR
   
   Returns the exclusive OR for argument1, argument2...argumentN.
   
   #+BEGIN_EXAMPLE
    XOR(0, 1, 0) = TRUE
   #+END_EXAMPLE

* Information
** CELL
   
   Returns information about a cell.
   
   
   #+BEGIN_SRC js
     var wb = new workbook();
     var ws = wb.sheet();

     assert( wb.run(ws, 'CELL("row", A1) = 1') );
     assert( wb.run(ws, 'CELL("col", A1) = 1') );

     assert( wb.run(ws, 'CELL("row", A2) = 2') );
     assert( wb.run(ws, 'CELL("col", B1) = 2') );

   #+END_SRC
   
** DEPENDENTS
   
   Returns the list of dependents for a given cell.
   
   #+BEGIN_SRC js
     var wb = new workbook();
     var sheet = wb.sheet();

     wb.set(sheet, {
         A1: "=SUM(A2:A3)",
         A2: 50,
         A3: 50,
         A4: "=A2 + A3"
     });

     var dependents = wb.run(sheet, "DEPENDENTS(A2)");
     assert( dependents.length == 2, "Should have 1 dependent");

     dependents = wb.run(sheet, "DEPENDENTS(A3)");
     assert( dependents.length == 2, "Should have 1 dependent");

     assert( "Sheet1!A1" === dependents[0], "Should be equal");
     assert( "Sheet1!A4" === dependents[1], "Should be equal");
   #+END_SRC
   
** TODO INFO
   
   Returns information about the operating environment running your workbook.

   |-----------+-----------------------------------------------------+-----------|
   | Text Type | Returns                                             | Supported |
   |-----------+-----------------------------------------------------+-----------|
   | directory | Location where spreadsheet is stored                |           |
   | numfile   | Count of active worksheets in all open workbooks    |           |
   | origin    | #NA!                                                |           |
   | osversion | Returns browser or container version                |           |
   | recalc    | Current recalculation mode; "Automatic" or "Manual" |           |
   | release   | Version number; as text                             |           |
   | system    | Return browser or container name                    |           |
   |-----------+-----------------------------------------------------+-----------|

   #+BEGIN_SRC js
     // TBD: Make this work!
     var wb = new workbook();
     var ws = wb.sheet();
     ws.run('INFO("directory")');
     ws.run('INFO("numfile")');
     ws.run('INFO("origin")');
     ws.run('INFO("")');
     ws.run('INFO("directory")');
     ws.run('INFO("directory")');
   #+END_SRC

** ISARRAY
   
   Tests if the value is an array.
   
   #+BEGIN_EXAMPLE
   ISARRAY({1,2,3}) = TRUE
   #+END_EXAMPLE
   
   #+BEGIN_EXAMPLE
   ISBLANK("FOO") = FALSE
   #+END_EXAMPLE

** ISBLANK
   
   Tests if the value is blank (empty).
   
   #+BEGIN_SRC js
     var wb = new workbook();
     var ws = wb.sheet();

     wb.set(0, "A1", null);
     wb.set(0, "A2", undefined);
     wb.set(0, "A3", "");
     wb.set(0, "A4", "Hello");

     assert(wb.run(0, 'ISBLANK(A1) = TRUE'), "A1 should be blank");
     assert(wb.run(0, 'ISBLANK(A2) = TRUE'), "A2 should be blank");
     assert(wb.run(0, 'ISBLANK(A3) = FALSE'), "A3 should not be blank"); // empty string is not blank
     assert(wb.run(0, 'ISBLANK(A4) = FALSE'), "A4 should not be blank");
   #+END_SRC

** TODO ISEMAIL
** ISERR
   
   Test for any error but #N/A.
   
   #+BEGIN_SRC js
     var wb = new workbook();
     var ws = wb.sheet();
     wb.set(ws, "A1", workbook.errors.na);
     wb.set(ws, "A2", workbook.errors.div0);
     wb.set(ws, "A3", Number.POSITIVE_INFINITY);

     assert(
         wb.run(ws, "ISERR(A1) = FALSE"),
         "A1 should not be error"
     );

     assert(
         wb.run(ws, "ISERR(A2) = TRUE"),
         "A2 should be error"
     );

     assert(
         wb.run(ws, "ISERR(A3) = TRUE"),
         "A3 should be error"
     );

   #+END_SRC
   
** ISERROR
   
   Test for error.
   
   #+BEGIN_SRC js
     var wb = new workbook();
     var ws = wb.sheet();
     wb.set(ws, "A1", workbook.errors.na);
     wb.set(ws, "A2", workbook.errors.div0);
     wb.set(ws, "A3", Number.POSITIVE_INFINITY);

     assert(
         wb.run(ws, "ISERROR(A1) = TRUE"),
         "A1 should be error"
     );

     assert(
         wb.run(ws, "ISERROR(A2) = TRUE"),
         "A2 should be error"
     );

     assert(
         wb.run(ws, "ISERROR(A3) = TRUE"),
         "A3 should be error"
     );

   #+END_SRC
   
** ISEVEN
   
   Test for even number.
   
   #+BEGIN_SRC js
      assert( workbook.run('ISEVEN(1) = FALSE'), "should be true");
      assert( workbook.run('ISEVEN(2) = TRUE'), "should be true");
   #+END_SRC
   
   Test values in a worksheet.
   
   #+BEGIN_SRC js
     var wb = new workbook();
     var ws = wb.sheet();
     wb.set(ws, "A1", 1)
     wb.set(ws, "A2", 2)
     assert( wb.run(ws, "ISEVEN(A1) = FALSE"), "should be true" );
     assert( wb.run(0, "ISEVEN(A2) = TRUE"), "should be true" );
   #+END_SRC
   
** ISFORMULA
   
   Test if cell has formula.
   
   #+BEGIN_SRC js
     var wb = new workbook();
     var ws = wb.sheet();
     wb.set(ws, "A1", 2);
     wb.set(ws, "A2", "=A1^8");
     assert( wb.run(0, "ISFORMULA(A1) = FALSE") );
     assert( wb.run(0, "ISFORMULA(A2) = TRUE") );
   #+END_SRC
   
** ISLOGICAL
   
   Test for TRUE or FALSE
   
   #+BEGIN_EXAMPLE
   ISLOGICAL(1) = FALSE
   #+END_EXAMPLE
   
   #+BEGIN_EXAMPLE
   ISLOGICAL("HELLO") = FALSE
   #+END_EXAMPLE
   
   #+BEGIN_EXAMPLE
   ISLOGICAL(TRUE) = TRUE
   #+END_EXAMPLE
   
   #+BEGIN_EXAMPLE
   ISLOGICAL(FALSE) = TRUE
   #+END_EXAMPLE

** ISNA
   
   Test for NA error.
   
   #+BEGIN_EXAMPLE
   ISNA("foo") = FALSE
   #+END_EXAMPLE
   
   #+BEGIN_EXAMPLE
   ISNA(NA()) = TRUE
   #+END_EXAMPLE

** ISNONTEXT
   
   Test for non text
   
   #+BEGIN_EXAMPLE
   ISNONTEXT("foo") = FALSE
   #+END_EXAMPLE
   
   #+BEGIN_EXAMPLE
   ISNONTEXT(NA()) = TRUE
   #+END_EXAMPLE

** ISNUMBER
   
   Returns TRUE if the *value_to_check* is a number.
   
   #+BEGIN_EXAMPLE
   ISNUMBER("FOO") = FALSE
   #+END_EXAMPLE
   
   #+BEGIN_EXAMPLE
   ISNUMBER(1)
   #+END_EXAMPLE

** ISODD
   
   Returns true if the value is odd.
   
   #+BEGIN_EXAMPLE
   ISODD(1) = TRUE
   #+END_EXAMPLE
   
   #+BEGIN_EXAMPLE
   ISODD(2) = FALSE
   #+END_EXAMPLE

** ISTEXT
   
   Returns TRUE if the value is text.
   
   #+BEGIN_EXAMPLE
   ISTEXT("foo") = TRUE
   #+END_EXAMPLE
   
   #+BEGIN_EXAMPLE
   ISTEXT(2) = FALSE
   #+END_EXAMPLE

** ISRANGE
   
   Return TRUE when the value is a range or a cell reference.
   
   #+BEGIN_SRC js
     var wb = new workbook();
     var ws = wb.sheet();

     assert( wb.run(ws, "ISRANGE(A1:A3)"), "A1:A3 is not a range" );
     assert( wb.run(ws, 'ISRANGE(OFFSET(A1,0,0,2,2))'), "OFFSET function not returning range" );
        
   #+END_SRC
   
** ISREF
   
   Return TRUE when the value is a range or a cell reference.
   
   #+BEGIN_SRC js
      wb = new workbook();
      ws = wb.sheet();

      assert( ws.run('ISREF(A1) = TRUE') );
      assert( ws.run('ISREF("FOO") = FALSE') );
         
   #+END_SRC
   
** TODO ISURL
** N
   
   Returns a value converted to a number.
   
   #+BEGIN_EXAMPLE
     N("5.2") = 0
   #+END_EXAMPLE
   
   #+BEGIN_EXAMPLE
     N(NA()) = NA()
   #+END_EXAMPLE
   
   #+BEGIN_EXAMPLE
     N(TRUE) = 1
   #+END_EXAMPLE
   
** NA
   
   Returns the error "#NA!"
   
   #+BEGIN_SRC js
      assert( workbook.run( "NA()" ) === workbook.errors.na, "should be true" );
   #+END_SRC
   
** PRECEDENTS
   
   Return the list of precedents for a given cell.
   
   #+BEGIN_SRC js
     var wb = new workbook();
     var sheet = wb.sheet();

     sheet.set({
         A1: "=SUM(A2:A3)",
         A2: 50,
         A3: 50,
         A4: "=A2+Sheet1!A3"
     });

     var precedents = sheet.run("PRECEDENTS(A1)");
     assert( precedents.length == 1, "Should have 1 precedents");

     assert( precedents[0].type === "range", "Type should be range");
     assert( workbook.fn.ISRANGE(precedents[0].range), "Should be range object");

     precedents = sheet.run("PRECEDENTS(A4)");
     assert( precedents.length == 2, "Should have 2 precedents");

     assert( precedents[0].type === "cell", "Type should be cell");
     assert( precedents[0].subtype === "local", "Subtype should be local");
     assert( precedents[0].addr === "A2", "Addr should be A2");

     assert( precedents[1].type === "cell", "Type should be cell");
     assert( precedents[1].subtype === "remote", "Subtype should be local");
     assert( precedents[1].sheetName === "Sheet1", "Sheet name should be Sheet1");
     assert( precedents[1].addr === "A3", "Addr should be A3");

   #+END_SRC
   
** SHEET
   
   Returns a named worksheet.
   
   #+BEGIN_SRC js
      var ws = workbook.Current.sheet({ name: "TipCalculator" });
      assert( ws.run('=SHEET("TipCalculator")') );
   #+END_SRC
   
** SHEETS
   
   Returns the number of sheets in the workbook.
   
   #+BEGIN_SRC js
     var ws = workbook.Current.sheet({ name: "SheetCount" });
     assert( ws.run('SHEETS()') === Object.keys(workbook.Current.worksheets).length, "SHEETS returns unexpected value"  );
   #+END_SRC
   
** TYPE
   
   Returns the type of value. Use TYPE when the behavior of another function depends on the type of value in a particular cell.
   
   #+BEGIN_SRC js
     assert( workbook.run('=TYPE(1) = 1'), "number should be 1" );
     assert( workbook.run('=TYPE("Foo") = 2'), "string should be 2" );
     assert( workbook.run('=TYPE(TRUE) = 4'), "boolean should be 4" );
     assert( workbook.run('=TYPE(NA()) = 16'), "error should be 16" );
   #+END_SRC
   
* Lookup and Reference
** ADDRESS

   Returns a cell reference given a row and column.

   #+BEGIN_EXAMPLE
     ADDRESS(1, 1) = "$A$1"
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     ADDRESS(1, 2, 2) = "B$1"
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     ADDRESS(3, 2, 3) = "$B3"
   #+END_EXAMPLE   

** COLUMN
   
   Returns the column number of a specified cell.

   #+BEGIN_EXAMPLE
     COLUMN(A1) = "A"
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     COLUMN("A1") = "A"
   #+END_EXAMPLE

** COLUMNS

   Returns the number of columns in a specified array or range.

   #+BEGIN_EXAMPLE
     COLUMNS({1,2,3,4,5}) = 5
   #+END_EXAMPLE

   All columns must be same size.

   #+BEGIN_EXAMPLE
     COLUMNS({1,2,3,4,5;1,2,3,4,5}) = 5
   #+END_EXAMPLE

   When they are not the same size then #VALUE? is returned.

   #+BEGIN_EXAMPLE
     ISERROR(COLUMNS({1,2,3,4,5;1,2}))
   #+END_EXAMPLE

** HLOOKUP

   Lookup a value in a table hortizonally on the first row and retreive a value from the matching column and specified row.

*** Syntax
    
    HLOOKUP(lookup_value, lookup_array, index, exactmatch)
    
*** Examples
    #+BEGIN_EXAMPLE
    HLOOKUP("C", {{"A","B","C"},{1,2,3}}, 2) = 3
    #+END_EXAMPLE
    
** INDEX

   Lookup an index in an array or reference.
   
*** Array Form
**** Syntax
     INDEX(array, row_num, [column_num])
**** Examples

     #+BEGIN_EXAMPLE
       INDEX({{"A","B","C"}}, 1, 1) = "A"
     #+END_EXAMPLE
     
     #+BEGIN_EXAMPLE
       INDEX({{"A","B","C"}}, 1, 2) = "B"
     #+END_EXAMPLE
     
     #+BEGIN_EXAMPLE
       INDEX({{"A","B","C"}, {"D"}}, 2) = "D"
     #+END_EXAMPLE

     #+BEGIN_EXAMPLE
       INDEX({"A","B","C";"D"}, 1, 3) = "C"
     #+END_EXAMPLE
     
*** Referenced Form
**** Syntax
     
     INDEX(reference, row_offset, [column_offset])
     
**** Examples
     #+BEGIN_SRC js
       var wb = new workbook();
       var ws =  wb.sheet();
       ws.set("A1", "A");
       ws.set("B1", "B");
       ws.set("C1", "C");
       ws.set("A2", "D");
       ws.set("B2", "E");
       ws.set("C2", "F");

       assert( ws.run('=INDEX(A1, 1, 1) = "A"' ), "Should be A" );
       assert( ws.run('=INDEX(A1:A3, 1, 2) = "B"' ), "Should be B" );
       assert( ws.run('=INDEX(A1:B4, 1, 3) = "C"' ), "Should be C" );


       assert( ws.run('=INDEX(A1:A3, 2, 1) = "D"' ), "Should be D" );
       assert( ws.run('=INDEX(A1, 2, 2) = "E"' ), "Should be E" );
       assert( ws.run('=INDEX(A1:Z10, 2, 3) = "F"' ), "Should be F" );

     #+END_SRC
     
** INDIRECT

   Returns a cell reference given a string.

   #+BEGIN_EXAMPLE
     ISCELL(INDIRECT("A1"))
   #+END_EXAMPLE

** LOOKUP
*** Vector Form
**** Syntax
     LOOKUP(lookup_value, lookup_vector, lookup_array)
**** Examples

     #+BEGIN_EXAMPLE
     LOOKUP("C", {"A","B","C"}, {1,2,3}) = 3
     #+END_EXAMPLE

*** TODO Array Form

    The array form searches the array by row or column depending on the dimensions of the array.

    If the array is wider then tall then the search is on the first row; the result being from the matching row and last column.

    If the array is taller then wide then the search is on the first column; the result being from the last row and matching column.

**** Syntax

     LOOKUP(lookup_value, lookup_array)

**** Examples

     Wide Array:
     #+BEGIN_EXAMPLE
       LOOKUP("C", {"A","B","C","D","E","F";"foo";1,2,3,4,5,6}) = 3
     #+END_EXAMPLE

     Tall Array:
     #+BEGIN_EXAMPLE
       LOOKUP("C", {"A",1;"B",2;"C",3;"D",4;"E",5;"F",6}) = 3
     #+END_EXAMPLE

** MATCH
    Returns the column matched by a *lookup_value* in a *lookup_reference*.
*** Syntax
    MATCH(lookup_value, lookup_reference, match_type)
*** Examples
    #+BEGIN_EXAMPLE
      =MATCH("b",{"a","b","c"},0) = 2
    #+END_EXAMPLE
    
    #+BEGIN_EXAMPLE
      =MATCH("a",{"aa","bb","cc"},0) = NA()   
    #+END_EXAMPLE
    
    #+BEGIN_EXAMPLE
      =MATCH("a?",{"aa","bb","cc"},0) = 1
    #+END_EXAMPLE
    
    #+BEGIN_EXAMPLE
      =MATCH("?b",{"aa","bb","cc"},0) = 2
    #+END_EXAMPLE
    
    #+BEGIN_EXAMPLE
      =MATCH("b~",{"aa","b?","cc"},0) = 2
    #+END_EXAMPLE
    
    #+BEGIN_EXAMPLE
      =MATCH("c*c",{"aa","b?","cfoobarc"},0) = 3
    #+END_EXAMPLE
    
    #+BEGIN_SRC js
      var wb = new workbook();
      var ws = wb.sheet();

      ws.set([["aa","bb","cc","dd","ee"]]); // set A1:A5
      assert( ws.run('MATCH("aa", A1:A5, 0) = 1'), "should return 1");
      assert( ws.run('MATCH("e?", A1:A5, 0) = NA()'), "should return 5" );
    #+END_SRC
    
** OFFSET
    Returns a reference to a cell a given number of rows and columns from a reference.
*** Syntax
    OFFSET(ref, rows, cols, height, width)
    
*** Examples

    #+BEGIN_SRC js
      var wb = new workbook();
      var ws = wb.sheet();
      wb.set(ws, "A1", 1);
      wb.set(ws, "B1", 2);
      wb.set(ws, "A2", 3);

      assert( wb.run(ws, '=+OFFSET(A1,0,1) = 2'), "Value should be 2" );
      assert( wb.run(ws, '=+OFFSET(A1,1,0) = 3'), "value should be 3" );
      assert( wb.run(ws, '=ISBLANK(OFFSET(A1,2,2))'), "value should be #NA!" );

    #+END_SRC
    
** ROW

   Returns the row number of a specified cell.

   #+BEGIN_EXAMPLE
     ROW(A1) = 1
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     ROW("B10") = 10
   #+END_EXAMPLE

** ROWS

   Returns the number of rows in a specified array or range.

   #+BEGIN_EXAMPLE
     ROWS({1;2;3;4;5;6}) = 6
   #+END_EXAMPLE

** VLOOKUP

   Lookup a value in a table hortizonally on the first row and retreive a value from the matching row and specified column.

*** Syntax
    
    VLOOKUP(lookup_value, lookup_reference, index, [exactmatch])
    
*** Examples
    
    #+BEGIN_EXAMPLE
      VLOOKUP("C", {"A",1;"B",2;"C",3}, 2) = 3
    #+END_EXAMPLE
    
* Date and Time
** DATE
    Returns a serial number that represents a date given a year, month and day.
*** Syntax
    DATE(year, month, day)
*** Examples

    #+BEGIN_EXAMPLE
     DATE( 2014, 01, 01 ) = 41640
    #+END_EXAMPLE
    
    #+BEGIN_EXAMPLE
     DATE( 2015, 3, 4 ) = 42067  
    #+END_EXAMPLE

** DATEVALUE
    Returns the serial number with *year*, *month* and *day*.
*** Syntax
    
    DATEVALUE(year, month, day)
    
    or
    
    DATEVALUE(date_text)

*** Examples    

    #+BEGIN_EXAMPLE
     DATEVALUE("01/01/2015") = 42005
    #+END_EXAMPLE
    
    #+BEGIN_EXAMPLE
      DATEVALUE(2015, 1, 1) = 42005
    #+END_EXAMPLE
    
** DATEDIF
   Calculates the number of days, months or years between two date.
*** Syntax
   
   DATEDIF(start_date, end_date, unit)
   
   Arguments:
   
   | start_date | The beginning of a period. Dates may be entered as text string, serial number or result of function (e.g. DATEVALUE("2015-01-01") |
   | end_date   | The end of a period.                                                                                                              |
   | unit       | The type of information you want to calculate.                                                                                    |
   
   Unit Types:
   
   | "Y"  | The number of complete years in the period                                                      |
   | "M"  | The number of complete months in the period                                                     |
   | "D"  | The number of days in the period                                                                |
   | "MD" | The difference between the days in the start_date and end_date. The month and year are ignored  |
   | "YM" | The difference between the months in the start_date and end_date. The days and year are ignored |
   | "YD" | The difference between the days in the start_date and end_date. The years are ignored           |
 
*** Examples

    #+BEGIN_EXAMPLE
      DATEDIF(DATE(2015, 1, 15), DATE(2015, 1, 16), "D") = 1
    #+END_EXAMPLE

    #+BEGIN_EXAMPLE
      DATEDIF("1/15/2015", "1/16/2015", "D") = 1
    #+END_EXAMPLE

    #+BEGIN_EXAMPLE
      DATEDIF("1/15/2014", "1/16/2015", "Y") = 1
    #+END_EXAMPLE

    #+BEGIN_EXAMPLE
      DATEDIF("12/15/2014", "1/16/2015", "M") = 1
    #+END_EXAMPLE

    #+BEGIN_EXAMPLE
      DATEDIF("10/01/2014", "1/31/2015", "M") = 3
    #+END_EXAMPLE

** DAY
   
   Returns the day of the month for a date.
   
   #+BEGIN_EXAMPLE
     DAY(DATE(2015, 1, 15)) = 15
   #+END_EXAMPLE
   
   #+BEGIN_EXAMPLE
     DAY("01/15/2015") = 15
   #+END_EXAMPLE
   
** DAYS360
   
   Returns the number of days between two dates based on a 360-day year.
   
   #+BEGIN_EXAMPLE
     DAYS360("30-Nov-2012", "1-Dec-2012") = 1
   #+END_EXAMPLE
   
** EDATE
   
   Returns the serial number for a date represented by a string or JSDate object.
   
   #+BEGIN_EXAMPLE
      EDATE(DATE(2015,1,15),1) = DATE(2015,2,15)
   #+END_EXAMPLE
   
** EOMONTH
   
   Returns the last day of the month.
   
   #+BEGIN_EXAMPLE
     EOMONTH( DATE( 2015, 3, 4), 0) = 42094
   #+END_EXAMPLE
   
** HOUR

   Accepts a serial number and returns the hour from 0-24.

   #+BEGIN_EXAMPLE
     HOUR(0) = 0
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     HOUR(0.5) = 12   
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     HOUR(0.99) = 23   
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     HOUR(29779.75) = 18   
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     HOUR( TIME(16, 20, 0) ) = 16
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     HOUR( TIMEVALUE("11:00PM") ) = 23   
   #+END_EXAMPLE

** ISLEAPYEAR
   
   Returns true if the date is a leap year
   
   #+BEGIN_EXAMPLE
     ISLEAPYEAR(DATE(2012,1,1))
   #+END_EXAMPLE

** WAIT ISOWEEKNUM						   :noexport:
** MINUTE

   Returns the minutes of a time value. The value is 0...59.

   #+BEGIN_EXAMPLE
     MINUTE( 0.78125 ) = 45
   #+END_EXAMPLE

** MONTH
   
   Returns the month for a date.
   
   #+BEGIN_EXAMPLE
     MONTH(DATEVALUE("1/1/2015")) = 1
   #+END_EXAMPLE
   
   #+BEGIN_EXAMPLE
     MONTH(DATEVALUE("6/15/2015")) = 6
   #+END_EXAMPLE
   
   #+BEGIN_EXAMPLE
     MONTH(DATE(2015, 1, 1)) = 1
   #+END_EXAMPLE
   
   #+BEGIN_EXAMPLE
     ISERR(MONTH(DATEVALUE("13/15/2015")))
   #+END_EXAMPLE
   
** WAIT NETWORKDAYS						   :noexport:
** NOW
   
   Returns the current date/time.
   
   #+BEGIN_EXAMPLE
     NOW()
   #+END_EXAMPLE
   
** SECOND

   Returns the seconds of a time value. The value is 0...59.

   #+BEGIN_EXAMPLE
     SECOND(  0.78125 ) = 0
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     31 = SECOND(  42001.78925 )      
   #+END_EXAMPLE

** TIME
   
   Returns a decimal representation of time.

   #+BEGIN_EXAMPLE
      TIME( 12, 0, 0) = 0.5
   #+END_EXAMPLE

** TIMEVALUE
   
   Parses text representation of time into decimal representation.

   #+BEGIN_EXAMPLE
      TIMEVALUE("6:00") = 0.25
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
      TIMEVALUE("12:00") = 0.5
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
      TIMEVALUE("18:00") = 0.75
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
      TIMEVALUE("12:00 PM") = 0.5
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     TIMEVALUE("12:00pm") = 0.5
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
      TIMEVALUE("1/1/2000 12:00 PM") = 0.5
   #+END_EXAMPLE

** TODAY
   
   Returns the current date.
   
   #+BEGIN_EXAMPLE
     TODAY() = FLOOR(NOW())
   #+END_EXAMPLE
   
** TODO WEEKDAY
** TODO WEEKNUM
** TODO WORKDAY
** YEAR
   
   Returns the year for a date.
   
   #+BEGIN_EXAMPLE
     YEAR(DATE(2014, 01, 01)) = 2014
   #+END_EXAMPLE

** TODO YEARFRAC
   
* Text
** WAIT ASC						      :i18n:noexport:

   For Double-byte character set (DBCS) languages, the function changes full-width (double-byte) characters to half-width (single-byte) characters.

** WAIT BAHTTEXT					      :i18n:noexport:

   Converts a number to Thai text and adds a suffix of "Baht."

** CLEAN

   Removes non-printing characters from ASCII data.

   #+BEGIN_EXAMPLE
     =CLEAN(CHAR(9)&"Monthly report"&CHAR(10)) = "Monthly report"
   #+END_EXAMPLE

** CHAR
   
   Returns the character for the ASCII code.
   
   #+BEGIN_EXAMPLE
    CHAR(97) = "a"
   #+END_EXAMPLE  
   
** CODE
   
   Returns the code for the ASCII character.
   
   #+BEGIN_EXAMPLE
     CODE("a") = 97
   #+END_EXAMPLE

** CONCATENATE
   
   Combines two or more strings into a single value.
   
   #+BEGIN_EXAMPLE
     CONCATENATE("Hello, ", "World") = "Hello, World"
   #+END_EXAMPLE

   The short name *CONCAT* refers to the same function.

   #+BEGIN_EXAMPLE
     CONCAT("Hello, ", "World") = "Hello, World"
   #+END_EXAMPLE

** WAIT DBCS						      :i18n:noexport:

   The function described in this Help topic converts half-width (single-byte) letters within a character string to full-width (double-byte) characters. The name of the function (and the characters that it converts) depends upon your language settings.

** DOLLAR

   Convert a number to formatted currency text with the format code: $#,##0.00_);($#,##0.00).

   #+BEGIN_EXAMPLE
     DOLLAR(1420.57) = "$1,420.57&nbsp;"
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     DOLLAR(-1420.57) = "($1,420.57)"
   #+END_EXAMPLE

** EXACT

   Compares two values and return TRUE only if the both are strings and both are identical content with a case-sensitive comparision.

   #+BEGIN_EXAMPLE
     EXACT("Hello", "Hello")
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     EXACT(1, 1) = NA()
   #+END_EXAMPLE

** FIND
   
   Returns the position of text.
   
   #+BEGIN_EXAMPLE
     FIND("a", "fooabar") = 4
   #+END_EXAMPLE
   
   #+BEGIN_EXAMPLE
     FIND("bar", "fooabar") = 5
   #+END_EXAMPLE
   
   #+BEGIN_EXAMPLE
     ISERR( FIND("z", "fooabar") )
   #+END_EXAMPLE
   
   #+BEGIN_EXAMPLE
     FIND("foo", "fooabar") = 1
   #+END_EXAMPLE

** FIXED

   Rounds a number to a specified number of decimal places.

   #+BEGIN_EXAMPLE
     FIXED(1234.23, 1) = "1234.2"
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     FIXED(1234.23, 1, TRUE) = "1,234.2"
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     FIXED(123.237, 2, TRUE) = "123.24"
   #+END_EXAMPLE

** LEFT
   
   Returns a specified number of character starting from the left side.
   
   #+BEGIN_EXAMPLE
     LEFT("12345", 3) = "123"      
   #+END_EXAMPLE

** LEN
   
   Returns the length of a string.
   
   #+BEGIN_EXAMPLE
     LEN("12345") = 5
   #+END_EXAMPLE
   
** LOWER
   
   Sets the text to lower case.
   
   #+BEGIN_EXAMPLE
    LOWER("TeSt") = "test"
   #+END_EXAMPLE

** JOIN

   Join an array into a string with a specified delimiter.

   #+BEGIN_EXAMPLE
     JOIN(",", {1,2,3}, {4;5;6}) = "1,2,3,4,5,6"
   #+END_EXAMPLE

** MID
   
   Returns the a section from a text string; based on the specified text, start position and number of characters.
   
   #+BEGIN_EXAMPLE
     MID("12345", 2, 3) = "234"
   #+END_EXAMPLE

** WAIT NUMBERVALUE						   :noexport:

   Converts text to a number, in a locale-independent way.
 
** WAIT PRONETIC				     :i18n:furigana:noexport:
** PROPER
   
   Converts a text string to proper case.
   
   #+BEGIN_EXAMPLE
     PROPER("heLLo") = "Hello"
   #+END_EXAMPLE

** REPLACE
   
   REPLACE( old_text, start, number_of_chars, new_text )
   
   #+BEGIN_EXAMPLE
     REPLACE("apples", 2, 5, "te") = "ate"   
   #+END_EXAMPLE

** REPT

   Repeat a string a given number of times.

   #+BEGIN_EXAMPLE
     REPT("-*", 3) & "-" = "-*-*-*-"
   #+END_EXAMPLE

** RIGHT
   
   Returns a specified number of character starting from the right side.
   
   #+BEGIN_EXAMPLE
     RIGHT("12345", 2) = "45"
   #+END_EXAMPLE

** TODO SEARCH							   :noexport:
   
   Search for text with wildcards.
   
   #+BEGIN_EXAMPLE
   
   #+END_EXAMPLE
   
   #+BEGIN_SRC js
     display(workbook.run('FIND("a", "fooabar")')); // should return 4
     display(workbook.run('FIND("bar", "fooabar")')); // should return 5
     display(workbook.run('FIND("z", "fooabar")')); // should return !VALUE?
     display(workbook.run('FIND("foo", "fooabar")')); // should return 1
   #+END_SRC

** SPLIT
   
   Split a string by a specified delimiter.
   
   #+BEGIN_EXAMPLE
      LEN(SPLIT("1,2,3", ",")) = 3
   #+END_EXAMPLE

** SUBSTITUTE
   
   SUBSTITUTE(text,old_text,new_text,instance_num)
   
   #+BEGIN_EXAMPLE
     SUBSTITUTE("Hello, {name}", "{name}", "Bob") = "Hello, Bob"
   #+END_EXAMPLE

** T
   
   Return text or empty string
   
   #+BEGIN_EXAMPLE
   T("123") = "123"
   #+END_EXAMPLE
   
   #+BEGIN_EXAMPLE
   T(123) = ""
   #+END_EXAMPLE

** TEXT
   
   TEXT(rawValue, formatCode[, currentCode]) : Format numbers, currency, date and time. 
   
   #+BEGIN_EXAMPLE
     TEXT(0.5, "hh:mm") = "12:00"
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     TEXT(0, "hh:mm AM/PM") = "12:00 AM"
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     TEXT(0.5, "hh:mm AM/PM") = "12:00 PM"
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     TEXT(1.0, "hh:mm AM/PM") = "12:00 AM"
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     TEXT(40000, "yyyy") = "2009"
   #+END_EXAMPLE
   
   #+BEGIN_EXAMPLE
     TEXT(0.43432, "0.00%") = "43.43%"
   #+END_EXAMPLE
   
   #+BEGIN_EXAMPLE
     TEXT(40000, "$0.00") = "$40000.00"
   #+END_EXAMPLE
   
** TRIM

   #+BEGIN_EXAMPLE
   TRIM("    text     ") = "text"
   #+END_EXAMPLE

** UPPER
   
   Sets the text to upper case.
   
   #+BEGIN_EXAMPLE
   UPPER("test") = "TEST"
   #+END_EXAMPLE

** VALUE

   Converts text into a number.

   #+BEGIN_EXAMPLE
     =VALUE("1000") = 1000
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     =VALUE("$1000") = 1000
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     =VALUE("$1,000") = 1000
   #+END_EXAMPLE
   
* Math
** ABS
*** Syntax
    
    ABS(number)
    
*** Description
    
    Returns the absolute value of a number.
    
*** Examples
    #+BEGIN_EXAMPLE
    ABS(-12) = 12
    #+END_EXAMPLE
    
    #+BEGIN_EXAMPLE
    ABS(12) = 12
    #+END_EXAMPLE
    
    #+BEGIN_EXAMPLE
    ABS(-100) = 100
    #+END_EXAMPLE
    
** ACOS
   
   Returns the Inverse Cosine 
   
   #+BEGIN_EXAMPLE
   ACOS(0.75) = 0.7227342478134157
   #+END_EXAMPLE

** ACOSH
   
   Returns the hyperbolic arccosine of a number.
   
   #+BEGIN_EXAMPLE
   ACOSH(2) = 1.3169578969248166
   #+END_EXAMPLE

** ACOT
   
   Returns the principal value of the arccotangent, or inverse cotangent, of a number.
   
   #+BEGIN_EXAMPLE
   ACOT(2) = 0.46364760900080615
   #+END_EXAMPLE

** ACOTH
   
   Returns the inverse hyperbolic cotangent of a number.
   
   #+BEGIN_EXAMPLE
   ACOTH(6) = 0.16823611831060645
   #+END_EXAMPLE

** ADD
   
   Add two factors.
   
   #+BEGIN_EXAMPLE
   ADD(2, 2) = 4
   #+END_EXAMPLE
   
** TODO AGGREGATE

   Returns an aggregate in a list or database. 

   Reference form

   AGGREGATE(function_num, options, ref1, [ref2], …)

   Array form

   AGGREGATE(function_num, options, array, [k])

   Agreement Functions:

   | function_num | Function       |
   |--------------+----------------|
   |            1 | AVERAGE        |
   |            2 | COUNT          |
   |            3 | COUNTA         |
   |            4 | MAX            |
   |            5 | MIN            |
   |            6 | PRODUCT        |
   |            7 | STDEV.S        |
   |            8 | STDEV.P        |
   |            9 | SUM            |
   |           10 | VAR.S          |
   |           11 | VAR.P          |
   |           12 | MEDIAN         |
   |           13 | MODE.SNGL      |
   |           14 | LARGE          |
   |           15 | SMALL          |
   |           16 | PERCENTILE.INC |
   |           17 | QUARTILE.INC   |
   |           18 | PERCENTILE.EXC |
   |           19 | QUARTILE.EXC   |

** TODO ARABIC

   Converts a Roman numeral to an Arabic numeral.

** ASIN
   
   Returns the arcsine, or inverse sine, of a number.
   
   #+BEGIN_EXAMPLE
     ASIN(-0.5) = -0.5235987755982988
   #+END_EXAMPLE

** ASINH
   
   Returns the hyperbolic arcsine of a number.
   
   #+BEGIN_EXAMPLE
   ASINH(10) = 2.99822295029797
   #+END_EXAMPLE

** ATAN
   
   Returns the arctangent (in radians) of a number.
   
   #+BEGIN_EXAMPLE
   ATAN(10) = 1.4711276743037345
   #+END_EXAMPLE

** ATAN2
   
   Returns the arctangent of the quotient of its arguments.
   
   #+BEGIN_EXAMPLE
   ATAN2(90, 15) = 1.4056476493802699
   #+END_EXAMPLE

** ATANH
   
   Returns the hyperbolic arctangent of a number.
   
   #+BEGIN_EXAMPLE
   ATANH(0.5) = 0.5493061443340549
   #+END_EXAMPLE

** BASE							   
   
   Converts a number into a text representation with the given radix (base).
   
   #+BEGIN_EXAMPLE
     BASE(7,2) = "111"
   #+END_EXAMPLE
   
** CEILING							   
   
   Returns number rounded up, away from zero, to the nearest multiple of significance. 
   
   #+BEGIN_EXAMPLE
     CEILING(2.5, 1) = 3
   #+END_EXAMPLE
   
   #+BEGIN_EXAMPLE
     CEILING(-2.5, -2) = -4
   #+END_EXAMPLE
   
   #+BEGIN_EXAMPLE
     CEILING(-2.5, 2) = -2
   #+END_EXAMPLE
   
   #+BEGIN_EXAMPLE
     CEILING(1.5, 0.1) = 1.5
   #+END_EXAMPLE
   
   #+BEGIN_EXAMPLE
     CEILING(0.234, 0.01) = 0.24
   #+END_EXAMPLE
   
** COMBIN							   
   
   Returns the number of combinations for a given number of items.
   
   #+BEGIN_EXAMPLE
     COMBIN(8,2) = 28
   #+END_EXAMPLE
   
** TODO COMBINA							   

   Returns the number of combinations (with repetitions) for a given number of items.

** COS							   
   
   Returns the cosine of the given angle.
   
   #+BEGIN_EXAMPLE
     0.5001710745970701=COS(1.047)
   #+END_EXAMPLE
   
** COSH
   
   Returns the hyperbolic cosine of a number.
   
   #+BEGIN_EXAMPLE
     27.308232836016483 = COSH(4)
   #+END_EXAMPLE
   
** COT							   
   
   Return the cotangent of an angle specified in radians.
   
   #+BEGIN_EXAMPLE
     -0.15611995216165922 = COT(30)
   #+END_EXAMPLE
   
** COTH							   
   
   Return the hyperbolic cotangent of a hyperbolic angle.
   
   #+BEGIN_EXAMPLE
     1.0373147207275482 = COTH(2)
   #+END_EXAMPLE
   
** CSC							   
   
   Returns the cosecant of an angle specified in radians.
   
   #+BEGIN_EXAMPLE
     1.5377805615408537 = CSC(15)
   #+END_EXAMPLE
   
** CSCH							   
   
   Return the hyperbolic cosecant of an angle specified in radians.
   
   #+BEGIN_EXAMPLE
     0.46964244059522464=CSCH(1.5)
   #+END_EXAMPLE
   
** DECIMAL							   
   
   Converts a text representation of a number in a given base into a decimal number.
   
   #+BEGIN_EXAMPLE
     255 = DECIMAL("FF",16)
   #+END_EXAMPLE

** DEGREES							   
   
   Converts radians into degrees.
   
   #+BEGIN_EXAMPLE
     180 = DEGREES(PI())
   #+END_EXAMPLE

** DIVIDE							   

   Divide two factors.

   #+BEGIN_EXAMPLE
     DIVIDE(10, 5) = 2
   #+END_EXAMPLE

** EQ							   
   
   Check equivalence of two factors.

   #+BEGIN_EXAMPLE
     EQ(1, +"1") 
   #+END_EXAMPLE

** EVEN							   
   
   Returns number rounded up to the nearest even integer. 
   
   #+BEGIN_EXAMPLE
     2=EVEN(1.5)
   #+END_EXAMPLE
   
   #+BEGIN_EXAMPLE
     4=EVEN(3)
   #+END_EXAMPLE
   
   #+BEGIN_EXAMPLE
     2=EVEN(2)
   #+END_EXAMPLE
   
   
   #+BEGIN_EXAMPLE
     -2=EVEN(-1)
   #+END_EXAMPLE
   
** EXP							   

   Returns e raised to the power of number.


   #+BEGIN_EXAMPLE
     EXP(10) = 22026.465794806707
   #+END_EXAMPLE

** FACT

   Returns the factorial of a number.

   #+BEGIN_EXAMPLE
     FACT(5) = 120
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     FACT(1.9) = 1
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     FACT(0)  = 1
   #+END_EXAMPLE

** FACTDOUBLE						   

   Returns the double factorial of a number.

   #+BEGIN_EXAMPLE
     FACTDOUBLE(6) = 48
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     FACTDOUBLE(7) = 105
   #+END_EXAMPLE

** FLOOR
   
   Returns a number rounded down to a multiple of another number.
   
   #+BEGIN_EXAMPLE
   FLOOR(2.5, 1) = 2
   #+END_EXAMPLE
   
   #+BEGIN_EXAMPLE
   FLOOR(0.234, 0.01) = 0.23
   #+END_EXAMPLE

** TODO GCD

   Returns the greatest common divisor of two or more integers. The greatest common divisor is the largest integer that divides both number1 and number2 without a remainder.

   #+BEGIN_EXAMPLE
     GCD(5, 2) = 1
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     GCD(24, 36) = 12
   #+END_EXAMPLE

** GT							   
   
   Returns true when a > b.

   #+BEGIN_EXAMPLE
     GT(4, 2)
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     NOT(GT(2, 4))
   #+END_EXAMPLE

** GTE							   

   Returns true when a >= b.

   #+BEGIN_EXAMPLE
     GTE(4, 2)
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     GTE(2, 2)
   #+END_EXAMPLE

** INT							   

   Rounds a number down to the nearest integer.

   #+BEGIN_EXAMPLE
     INT(8.9) = 8
   #+END_EXAMPLE

** TODO LCM							   
** LOG
   
   Returns a number rounded down to a multiple of another number.
   
   #+BEGIN_EXAMPLE
   LOG(10) = 1
   #+END_EXAMPLE
   
   #+BEGIN_EXAMPLE
   LOG(86, 2.7182818) = 4.454347342888286
   #+END_EXAMPLE

** LOG10

   Returns the base-10 logarithm of a number.
   
   #+BEGIN_EXAMPLE
     LOG10(10) = 1
   #+END_EXAMPLE

** LT

   Returns true when a < b.

   #+BEGIN_EXAMPLE
     LT(2, 4)
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     NOT(LT(4, 2))
   #+END_EXAMPLE

** LTE

   Returns true when a >= b.

   #+BEGIN_EXAMPLE
     LTE(2, 4)
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     LTE(2, 2)
   #+END_EXAMPLE

** TODO MDETERM

   Returns the matrix determinant of an array.

   Look at https://github.com/sloisel/numeric/blob/master/src/numeric.js for ideas to implement.

** MINUS

   Subtract two factors.

   #+BEGIN_EXAMPLE
     MINUS(2, 2) = 0
   #+END_EXAMPLE

** TODO MINVERSE

   Returns the inverse matrix for the matrix stored in an array.

** TODO MMULT

   Returns the matrix product of two arrays. The result is an array with the same number of rows as array1 and the same number of columns as array2.

** MOD

   Returns the remainder when of two factors.

   #+BEGIN_EXAMPLE
     MOD(3, 2) = 1
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     MOD(11, 3) = 2
   #+END_EXAMPLE

** TODO MROUND

   Returns a number rounded to the desired multiple.

** TODO MULTINOMIAL

   Returns the ratio of the factorial of a sum of values to the product of factorials.

** MULTIPLY

   Multiply two factors.

   #+BEGIN_EXAMPLE
     MULTIPLY(2, 2) = 4
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     MULTIPLY(4, 2) = 8   
   #+END_EXAMPLE

** TODO ODD

   Returns number rounded up to the nearest odd integer.

** PI

   Returns the value for the univeral constant PI.

   #+BEGIN_EXAMPLE
   PI() = 3.141592653589793
   #+END_EXAMPLE

** POWER
   
   Returns the the nth power of a number.

   #+BEGIN_EXAMPLE
     POWER(16, 2) = 256
   #+END_EXAMPLE

** PRODUCT

   Returns the product of the arguments.

   #+BEGIN_EXAMPLE
     PRODUCT( 3, 6, 2, 8, 5 ) = 1440
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     PRODUCT( 2, 2, 2, 2 ) = 16
   #+END_EXAMPLE

** QUOTIENT

   Returns the integer portion of a divisor.

   #+BEGIN_EXAMPLE
     QUOTIENT(5, 2) = 2
   #+END_EXAMPLE

** RADIANS

   Convert degrees to radians.

   #+BEGIN_EXAMPLE
     RADIANS(180) = PI()
   #+END_EXAMPLE

** RAND

   Generate a random number.

   #+BEGIN_EXAMPLE
     RAND()
   #+END_EXAMPLE

** RANDBETWEEN

   Generate a random number between two values.

   #+BEGIN_EXAMPLE
     RANDBETWEEN(0, 100)
   #+END_EXAMPLE

** TODO ROMAN

   Converts an arabic numeral to roman, as text.

** ROUND
   
   Round number with precision.
   
   #+BEGIN_EXAMPLE
   ROUND(14.20223234, 2) = 14.20
   #+END_EXAMPLE

** TODO ROUNDDOWN
** ROUNDUP
   
   Rounds a number up, away from 0 (zero).
   
   #+BEGIN_EXAMPLE
     4 = ROUNDUP(3.2,0)
   #+END_EXAMPLE
   
   #+BEGIN_EXAMPLE
   77 = ROUNDUP(76.9,0)
   #+END_EXAMPLE
   
   #+BEGIN_EXAMPLE
   3.142 = ROUNDUP(3.14159, 3)
   #+END_EXAMPLE
   
   #+BEGIN_EXAMPLE
   -3.2 = ROUNDUP(-3.14159, 1)
   #+END_EXAMPLE  

** TODO SEC
** TODO SECH
** TODO SERIESSUM
** TODO SIGN
** TODO SIN
** TODO SQRT
** TODO SQRTPI
** TODO SUBTOTAL
** SUM
   
   Calculate SUM of list of numbers.
   
   #+BEGIN_EXAMPLE
   SUM({1,1,1,1}, 10) = 14
   #+END_EXAMPLE
   
* Financial
** ACCRINT
   
   Returns the accrued interest for a security that pays periodic interest.
   
   #+BEGIN_EXAMPLE
    183.88888888888889 = ACCRINT("2/2/2012", "3/30/2012", "12/4/2013",0.1,1000,1,0,1)  
   #+END_EXAMPLE
   
   #+BEGIN_EXAMPLE
    183.88888888888889 = ACCRINT(DATE(2012,2,2),DATE(2012,3,20),DATE(2013,12,4),0.1,1000,1,0,1)
   #+END_EXAMPLE
   
*** Example:  Accrued interest test				   :noexport:

    #+NAME:  AccruedInterestTest
    |----------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
    | Data                                         | Description                                                                                                                                                                |
    |----------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
    | 3/1/2008                                     | Issue date                                                                                                                                                                 |
    | 8/31/2008                                    | First interest date                                                                                                                                                        |
    | 5/1/2008                                     | Settlement date                                                                                                                                                            |
    | =10.0%                                       | Coupon rate                                                                                                                                                                |
    | =1000                                        | Par value                                                                                                                                                                  |
    | =2                                           | Frequency is semiannual (see above)                                                                                                                                        |
    | =0                                           | 30/360 basis (see above)                                                                                                                                                   |
    | Formula                                      | Description (Result)                                                                                                                                                       |
    |----------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
    | =ACCRINT(A2,A3,A4,A5,A6,A7,A8)               | Accrued interest for a treasury bond with the terms above (16.66666667)                                                                                                    |
    | =ACCRINT(DATE(2008,3,5),A3,A4,A5,A6,A7,A8,0) | Accrued interest with the terms above, except the issue date is March 5, 2008. (15.55555556)                                                                               |
    | =ACCRINT(DATE(2008,3,5),A3,A4,A5,A6,A7,A8,0) | Accrued interest with the terms above, except the issue date is April 5, 2008, and the accrued interest is calculated from the first_interest to settlement. (7.222222222) |
    |----------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
    
** TODO ACCRINTM

   Returns the accrued interest for a security that pays interest at maturity.

*** Syntax

    ACCRINTM(issue, settlement, rate, par, [basis])

** TODO AMORLINC

   Returns the depreciation for each accounting period. This function is provided for the French accounting system. 
   If an asset is purchased in the middle of the accounting period, the prorated depreciation is taken into account.

** TODO COUPDAYS

   Returns the number of days in the coupon period that contains the settlement date.

** TODO COUPDAYSNC

   Returns the number of days from the settlement date to the next coupon date.

** TODO COUPNCD

   Returns a number that represents the next coupon date after the settlement date.

** TODO COUPNUM

   Returns the number of coupons payable between the settlement date and maturity date, rounded up to the nearest whole coupon.

** TODO COUPPCD

   Returns a number that represents the previous coupon date before the settlement date.

** TODO CUMIPMT

   Returns the cumulative interest paid on a loan between start_period and end_period.

** TODO CUMPRINC

   Returns the cumulative principal paid on a loan between start_period and end_period.

** TODO DB

   Returns the depreciation of an asset for a specified period using the fixed-declining balance method.

** TODO DDB

   Returns the depreciation of an asset for a specified period using the double-declining balance method or some other method you specify.

** TODO DISC

   Returns the discount rate for a security.

** TODO DOLLARDE
** TODO DOLLARFR
** TODO DURATION
** TODO EFFECT
** FV
   
   Returns the future value of an initial sum with a subsequent stream of payments.
   
   #+BEGIN_EXAMPLE
    =FV(7.5%/12, 2*12, -250, -5000, 1) = 12298.46381980343
   #+END_EXAMPLE
   
** TODO FVSCHEDULE
** TODO INTRATE
** TODO IRR
** IPMT
   Returns the portion of the periodic payment which is interest for a fixed rate loan or annuity.
   
   #+BEGIN_EXAMPLE
      IPMT(10%, 3, 3, 8000) = -292.4471299093658
   #+END_EXAMPLE
   
** TODO MDURATION
** TODO MIRR
** TODO NOMINAL
** NPER
   
   Returns the number of payment periods for an annuity.
   
   #+BEGIN_EXAMPLE
     NPER(12%/12, -100, -1000, 10000, TRUE) = 59.67386567429457
   #+END_EXAMPLE
   
** NPV
   Returns the net present value of an investment with regular cash payments.
   
   #+BEGIN_EXAMPLE
     NPV(10%, -10000, 3000, 4200, 6800) = 1188.4434123352207
   #+END_EXAMPLE
   
** TODO ODDFPRICE
** TODO ODDFYIELD
** PMT
   
   Returns the payment per period for a fixed rate loan.
   
   #+BEGIN_EXAMPLE
      PMT(8%/12, 10, 10000) = -1037.0320893591606
   #+END_EXAMPLE
   
** PV
   
   Returns the present value of a stream of future payments with a final lump sum.
   
   #+BEGIN_EXAMPLE
     PV(0.075/12, 2*12, 250, 0, 0) = -5555.605845933733
   #+END_EXAMPLE
   
* Stats
** TODO AVEDEV
** AVERAGE
   
   Compute the average of a range or array
   
   #+BEGIN_EXAMPLE
       AVERAGE({ 1, 2, 3, 4, 5}) = 3
   #+END_EXAMPLE
   
** TODO AVERAGEA
** TODO AVERAGEIF
** TODO AVERAGEIFS
** TODO CORREL
** TODO COUNT
** TODO COUNTA
** TODO COUNTIN
** TODO COUNTBLANK
** COUNTIF
   
   Return count of fields that match a criterion
   
   #+BEGIN_EXAMPLE
     COUNTIF({ "apples", "bananas", "grapes", "apples" }, "apples") = 2
   #+END_EXAMPLE
   
   #+BEGIN_EXAMPLE
     COUNTIF({ 1,1,2,3,5 }, 1) = 2
   #+END_EXAMPLE
   
   #+BEGIN_EXAMPLE
     COUNTIF({ 1,1,2,3,5 }, ">1") = 3
   #+END_EXAMPLE
   
** TODO COUNTIFS
** TODO COUNTUNIQUE
** TODO DEVSQ
** TODO FISHER
** TODO FISHERINV
** TODO FORECAST
** TODO FREQUENCY
** TODO GAMMALN
** TODO GEOMEAN
** TODO GROWTH
** TODO HARMEAN
** TODO INTERCEPT
** TODO KURT
** TODO LARGE
** TODO LINEST
** TODO LOGEST
** MAX
   
   Returns the maximum of a list of arguments, ignoring text entries
   
   #+BEGIN_EXAMPLE
       MAX({1,2,30,4}, 10) = 30
   #+END_EXAMPLE
   
** TODO MAXA
** TODO MEDIAN
** MIN
   Returns the minimum of a list of arguments, ignoring text entries
   #+BEGIN_EXAMPLE
       MIN({6,3,"foo",3,4}, 1) = 1
   #+END_EXAMPLE
   
** TODO MINA
** TODO PEARSON
** TODO PERMUT
** TODO PERMUTATIONA
** TODO PHI
** TODO PROB
** TODO RSQ
** TODO SKEW
** TODO SLOPE
** TODO SMALL
** TODO STANDARDIZE
** TODO STDEVA
** TODO STDEVPA
** TODO STEYX
** TODO TRANSPOSE
** TODO TREND
** TODO TRIMMEAN
** TODO VARA
** TODO VARPA
* Engineering
** TODO BESSELI
   
   #+BEGIN_EXAMPLE
     BESSELI(1.5, 1) = 0.981666428577908
   #+END_EXAMPLE
   
** TODO BESSELJ
   
   #+BEGIN_EXAMPLE
     BESSELJ(1.9, 2) = 0.329925727692387
   #+END_EXAMPLE
   
** TODO BESSELK
** TODO BESSELY
** BIN2DEC
   
   Convert a binary number to a decimal number with a maximum of 10 characters (bits). 
   
   #+BEGIN_EXAMPLE
     BIN2DEC(1111) = 15
   #+END_EXAMPLE
   
   #+BEGIN_EXAMPLE
     BIN2DEC("1111") = 15
   #+END_EXAMPLE
   
   #+BEGIN_EXAMPLE
     BIN2DEC("1011111111") = -257
   #+END_EXAMPLE
   
   #+BEGIN_EXAMPLE
     BIN2DEC("1111111111") = -1
   #+END_EXAMPLE
   
** TODO BIN2HEX
** TODO BIN2OCT
** TODO BITAND
** TODO BITLSHIFT
** TODO BITOR
** TODO BITRSHIFT
** TODO BITXOR
** TODO COMPLEX
** TODO CONVERT
** TODO DEC2BIN
** TODO DEC2HEX
** TODO DEC2OCT
** TODO DELTA
** TODO ERF
** TODO ERFC
** TODO GESTEP
** TODO HEX2BIN
** TODO HEX2DEC
** TODO HEX2OCT
** TODO IMABS
** TODO IMAGINARY
** TODO IMARGUMENT
** TODO IMCONJUGATE
** TODO IMCOS
** TODO IMCOSH
** TODO IMCOT
** TODO IMDIV
** TODO IMEXP
** TODO IMLN
** TODO IMLOG19
** TODO IMLOG2
** TODO IMPOWER
** TODO IMPRODUCT
** TODO IMREAL
** TODO IMSEC
** TODO IMSECH
** TODO IMSIN
** TODO IMSINH
** TODO IMSQRT
** TODO IMCSC
** TODO IMCSCH
** TODO IMSUB
** TODO IMTAN
** TODO OCT2BIN
** TODO OCT2DEC
** TODO OCT2HEX
   
* Size Limitations

  | Max Rows    | 1,048,576 |
  | Max Columns | 16,384    |

* Workbook Code 						   :noexport:
  :PROPERTIES: 
 :noweb-ref: WorkbookModel
 :END:      
** Construtor

   #+BEGIN_SRC js
     root.workbook = function workbook(config) {        
         
         this.auto = true; // auto-recalculate is the default.
         // planned
         //this.async = true; // enable async updates as default.
         
         if (typeof config === 'object') {
             if (config.hasOwnProperty("name")) { this.name = config.name; }
             if (config.hasOwnProperty("auto")) { this.auto = config.auto; }
             // planned
             //if (config.hasOwnProperty("async")) { this.async = config.async; }
         }

         // arrays to store named callbacks for events
         this.callbacks = { 
             set: [ ],
             updated: [ ],
         };
         
         // A map for cells to variable names
         this.namedRange = { };

         // formulas/functions metadata
         this.functions = { }; // functions indexed by id
         this.functionLookup = { }; // function ids indexed by exp

         // meta-meta systems
         this.cells             = [ ];  // cells by sheetIndex and cellIndex
         this.indirect          = [ ];  // A list of cell indirections: generated by OFFSET and INDIRECT functions
         this.ranges            = [ ];  // static and dynamic ranges by rangeId 
         this.rangeLookup       = { };  // lookup rangeId by sheetIndex, rangeIndex
         this.dynamicranges     = [ ];  // array of dynamic ranges
         this.graph             = [ ];  // a graph of dependencies by cellIndex [dep, prec]
       
         // track metadata about worksheets
         this.sheets = [ ]; // an array of worksheets
         this.sheetNames = [ ]; // an array of worksheet names with same index as sheets array
         this.sheetStore = { }; // a name/value pair of worksheet names to data storage store
         
         // keep track of dirty fields
         this.dirty = []
     }

     // Define function library container
     fn = workbook.fn = { };
     workbook.errors = error;

     // these functions always need to use .apply(ws, ...)
     workbook.CONTEXTUAL_FUNCTIONS = ["SHEETS", "SHEET", "INDIRECT"]; 
     workbook.ALWAYS_CONTEXTUAL = false; // always use .apply to set this to worksheet



   #+END_SRC
   
** cell

   #+BEGIN_SRC js
     workbook.prototype.cell = function(sheetIndex, ref) {
         var sheetName,
             sheetIndex = this.resolveSheet(sheetIndex),
             ci = workbook.cellInfo( ref );

             return new cell( this,
                              sheetIndex,
                              ci.rowIndex,
                              ci.colIndex );

     }
   #+END_SRC

** cellInfo
   
   Extracts the cell info from a string
   
   #+BEGIN_SRC js
     // Matches $A$1, $A1, A$1 or A1. 
     var cellRegex = /^(?:[$])?([a-zA-Z]+)(?:[$])?([0-9]+)$/;
     var cellInfoMem = {};
     workbook.cellInfo = function(addr) {

         if (cellInfoMem.hasOwnProperty(addr)) {
             return cellInfoMem[addr];
         }

         var matches = addr.match(cellRegex);
         
         if (matches === null) {
             throw Error("Ref does not match cell reference: " + addr);    
         } else {
             var result = {
                 addr: addr,
                 row: +matches[2],
                 col: matches[1],
                 colIndex: workbook.toColumnIndex(matches[1]),
                 rowIndex: +matches[2]-1
             };
             cellInfoMem[addr] = result;
             return result;
         }
     }
   #+END_SRC

** compile
   
   The compile function converts an expression or AST into a JavaScript function.
   
   The compiler supports 4 modes:
   - 1 : JS Function
   - 2 : Raw JS Expression
   - 3 : JS Expression wrapped in function
   - 4 : Precedents
     
   #+BEGIN_SRC js
     var precedents, suppress = false;
     workbook.compile = function(exp, mode) {
         var ast = exp,
             jsCode,
             functionCode,
             f,
             context = this;
         
         mode = mode || 1; // default to compile JSFunction
         
         // convert to AST when string provided
         if (typeof ast === 'string') {
             ast = workbook.parse(this, ast);
         } 

         precedents = []; // reset shared precedents
         jsCode =  workbook.compiler(ast);

         switch(mode) {
         case 1:
             var id = compiledNumber++;
             f = Function("context", "// formula: " + exp + "\nreturn " + jsCode + "\n//@ sourceURL=formula_function_" +
                          id + ".js");
             f.id = id;
             f.js = jsCode;
             f.exp = exp;
             f.ast = ast;
             f.precedents = precedents;
             
             return f;
         case 2:
             return jsCode;
         case 3:
             functionCode = "// formula: " + exp + "\nfunction(context) {\n  return " + jsCode + ";\n}";
             return functionCode;
         case 4:
             return precedents;
         }

     }

   #+END_SRC
   
** compiler

   The function that converts the AST to JavaScript.

   #+BEGIN_SRC js
     // define a compiler function to handle recurse the AST.
     workbook.compiler = function( node ) {
         
         var lhs, rhs, _name, dynamic = false;

         var compiler = workbook.compiler;
         
         // The node is expected to be either an operator, function or a value.
         switch(node.type) {
         case 'operator':
             switch(node.subtype) {
             case 'prefix-plus':
                 return '+' + compiler( node.operands[0] );
             case 'prefix-minus':
                 return '-' + compiler( node.operands[0] );
             case 'infix-add':
                 return ("workbook.fn.ADD(" + compiler( node.operands[0] ) + ',' +
                         compiler( node.operands[1]) + ")");
             case 'infix-subtract':
                 return ("workbook.fn.MINUS(" + compiler( node.operands[0] ) + ',' +
                         compiler( node.operands[1]) + ")");
             case 'infix-multiply':
                 return ("workbook.fn.MULTIPLY(" + compiler( node.operands[0] ) + ',' +
                         compiler( node.operands[1]) + ")");
             case 'infix-divide':
                 return ("workbook.fn.DIVIDE(" + compiler( node.operands[0] ) + ',' +
                         compiler( node.operands[1]) + ")");
             case 'infix-power':
                 return ('workbook.fn.POWER(' + compiler( node.operands[0] ) + ',' 
                         + compiler( node.operands[1] ) + ')')
             case 'infix-concat':
                 lhs = compiler( node.operands[0] );
                 rhs = compiler( node.operands[1] );
                             
                 return "workbook.fn.CONCAT(" + workbook.wrapString(lhs) + ', ' + workbook.wrapString(rhs) + ")";
             case 'infix-eq':
                 return ("workbook.fn.EQ(" + compiler( node.operands[0] ) + ',' +
                         compiler( node.operands[1]) + ")");                
             case 'infix-ne':
                 return ("workbook.fn.NE(" + compiler( node.operands[0] ) + ',' +
                         compiler( node.operands[1]) + ")");                                
             case 'infix-gt':
                 return ("workbook.fn.GT(" + compiler( node.operands[0] ) + ',' +
                         compiler( node.operands[1]) + ")");                                
             case 'infix-gte':
                 return ("workbook.fn.GTE(" + compiler( node.operands[0] ) + ',' +
                         compiler( node.operands[1]) + ")");                                
             case 'infix-lt':
                 return ("workbook.fn.LT(" + compiler( node.operands[0] ) + ',' +
                         compiler( node.operands[1]) + ")");                                
             case 'infix-lte':
                 return ("workbook.fn.LTE(" + compiler( node.operands[0] ) + ',' +
                         compiler( node.operands[1]) + ")");                
             }
             throw TypeException("Unknown operator: " + node.subtype);
         case 'group':
             return ('(' +  compiler( node.exp ) + ')');
         case 'function':
             switch (node.name) {
             case 'IF':
                 if ( node.args.length > 3) { throw Error("IF sent too many arguments."); }
                 if ( node.args.length !== 3) { throw Error("IF expects 3 arguments"); }
                 return ('((' + compiler( node.args[0] ) + 
                         ')?' + compiler( node.args[1] ) + 
                         ':' + compiler( node.args[2] ) + ')');
                 
             case 'NOT':
                 if ( node.args.length !== 1) { throw Error("NOT only accepts one argument"); }
                 return 'workbook.fn.NOT(' + compiler( node.args[0] ) + ')';
             case 'AND':
                 return ('workbook.fn.AND(' + 
                         node.args.map(function(n){ 
                             return compiler( n );
                         }).join(', ') + ')');                 
             case 'OR':
                 return ('workbook.fn.OR(' + 
                         node.args.map(function(n){ 
                             return compiler( n );
                         }).join(', ') + ')');     

             default:
                 
                 _name = function(name) {
                     return workbook.fn.hasOwnProperty(name)?"workbook.fn." + name:name;
                 }
                 

                 if ( workbook.ALWAYS_CONTEXTUAL || workbook.CONTEXTUAL_FUNCTIONS.indexOf(node.name) >= 0) {
                     return (_name(node.name) + '.apply( context, ' + 
                             (node.args.length > 0 ? "[" + node.args.map(function(n){ 
                                 return compiler( n );
                             }).join(',') + '] )' : '[] )'));
                 } else {
                     return (_name(node.name) + '( ' + node.args.map(function(n){ 
                         return compiler( n );
                     }).join(',') + ' )');
                 }
                 
                 
             }
         case 'cell':
             if (typeof precedents !== "undefined" && !suppress) { precedents.push(node); }

             if (node.subtype === "remote") {
                 return 'context.ref(\"' + node.worksheet + '\", \"' + node.addr + '\")';
             } else {
                 return 'context.ref(\"' + node.addr + '\")';
             }
         case 'range':

             if (typeof precedents !== "undefined") { precedents.push(node); suppress = true; }
             lhs = compiler(node.topLeft);
             rhs = compiler(node.bottomRight);
             suppress = false;
            
             // anonymous functions are the perfect solution for dynamic ranges but was not immediately obvious to me
             if ( node.topLeft.type === "function" ) {
                 lhs = "function() { return (" + lhs + "); }"
             }

             if ( node.bottomRight.type === "function" ) {
                 rhs = "function() { return (" + rhs + "); }"
             }
         
             return ('context.range( ' + lhs + ', ' + rhs + ' )' );
             
         case 'value':
             switch (node.subtype) {
             case 'array':
                 return ('[' + 
                         node.items.map(function(n){ 
                             return compiler( n );
                         }).join(',') + ']');
             case 'string':
                 return "'" + node.value.replace(/'/g, "''") + "'";
             case 'variable':

                 if (precedents && !suppress) { precedents.push(node); }
                 
                 if (node.subtype === "remote-named") {
                     return 'context.ref(\"' + node.worksheet + '\", \"' + node.value + '\")';
                 } else {
                     return 'context.ref(\"' + node.value + '\")';
                 }
                 
                 
             default:
                 return node.value;
             }
         }
     }

   #+END_SRC

** debug
   
   Add hooks to log actions to console.
   
   #+BEGIN_SRC js
     workbook.prototype.debug = function() {
         var self = this;
         this.on("set", function(sheetName, row, col, newValue, oldValue) {
             display(sheetName + " set from \"" + oldValue +
                     "\" to " + '"' + newValue + '"');
         });

         this.on("updated", function(sheetIndex, row, col, newValue, oldValue) {
             display(sheetName + " updated from \"" + oldValue +
                     "\" to " + '"' + newValue + '"');
         });

     }
   #+END_SRC
   
** expandGraph

   Resolve named ranges, dynamic references and ranges into flattened dependency graph.

   #+BEGIN_SRC js
     workbook.prototype.expandGraph = function() {
         throw "TBD";
     };
   #+END_SRC

** extractCellInfo
   
   Determines which combination of types maps to different overloaded versions of Worksheet.get.
   
   #+BEGIN_SRC js
     workbook.extractCellInfo = function(col, row) {
	 var cellInfo, cellName;
	 if (typeof col === "number" && typeof row === 'number') {
	     return workbook.cellInfo(workbook.toColumn(col) + (row+1).toString());
	 } else if (typeof col === "string" && typeof row === 'number') {
	     return workbook.cellInfo(col + row.toString());
	 } else if (typeof col === "string" && typeof row === 'undefined') {       
	     return workbook.cellInfo(col);
	 } else {
	     throw Error("Expects either row, col or cell name (e.g. A1)");
	 }         
     }    
   #+END_SRC
   
** findDependents

   #+BEGIN_SRC js
     workbook.prototype.findDependents = function( sheetIndex, cell ) {
         var list = [],
             cellIndex = cell.cellIndex;

         var currentItems;        
         
         if (fn.ISARRAY(this.graph)) {
             
             var graph = this.graph;
             
             // update the dependencies in a single loop through the dependency graph.
             
             for (var i = 0; i < graph.length; i++) {

                 var dependent = graph[i][0];
                 var precedent = graph[i][1];
                 
                 // circular-reference...continue
                 if (dependent.sheetIndex === cell.sheetIndex &&
                     dependent.addr === cell.addr) {
                     continue;
                 }

                 // check if precedent matches the cell being updated
                 // or if the range of precedents matches the cell.
                 if ( ((fn.ISCELL(precedent) &&
                        precedent.sheetIndex === cell.sheetIndex &&
                        precedent.addr === cell.addr) ||
                       (fn.ISRANGE(precedent) &&
                        precedent.sheetIndex === cell.sheetIndex &&
                        precedent.hit(cell.addr))) ) {


                     list.push(dependent);
                     
                     // concatenate with downstream dependencies
                     list = list.concat(this.findDependents(dependent.sheetIndex, dependent.cellIndex));
                 }
             }
             
         }

         return list;
     }
   #+END_SRC

** get

   #+BEGIN_SRC js
     workbook.prototype.get = function(sheetIndex, ref) {
         var sheet;

         sheetIndex = this.resolveSheet(sheetIndex);

         return this.ref(sheetIndex, ref);
     }
   #+END_SRC

** getValue
   
   Get a worksheet or a value in a worksheet.
   
   #+BEGIN_SRC js
     workbook.prototype.getValue = function(sheetIndex, row, col) {

         sheetIndex = this.resolveSheet(sheetIndex);

         var sheet = this.sheets[sheetIndex];
         
         switch(this.sheetStore[sheetIndex]) {
         case "col":
             if (typeof sheet[col] !== "undefined") {
                 return sheet[col][row];
             }
         case "row":
             if (typeof sheet[row] !== "undefined") {
                 return sheet[row][col];
             }
         default:
             return sheet[fn.ADDRESS(row+1, col+1, 0)];
         }
     }
   #+END_SRC

** format number
   
   The format number converts a numeric value into formatted text using a format code.
   
   This code was adapted from the SocialCalc project.
   
   #+BEGIN_SRC js

     workbook.FormatNumber = {};

     workbook.FormatNumber.format_definitions = {}; // Parsed formats are stored here globally


     // Other constants

     workbook.FormatNumber.commands =
	 {copy: 1, color: 2, integer_placeholder: 3, fraction_placeholder: 4, decimal: 5,
	  currency: 6, general:7, separator: 8, date: 9, comparison: 10, section: 11, style: 12};



     /* *******************

	result = workbook.FormatNumber.formatNumberWithFormat = function(rawvalue, format_string, currency_char)

	,************************* */

     workbook.FormatNumber.formatNumberWithFormat = function(rawvalue, format_string, currency_char) {

	 var scfn = workbook.FormatNumber;

	 var op, operandstr, fromend, cval, operandstrlc;
	 var startval, estartval;
	 var hrs, mins, secs, ehrs, emins, esecs, ampmstr, ymd;
	 var minOK, mpos;
	 var result="";
	 var thisformat;
	 var section, gotcomparison, compop, compval, cpos, oppos;
	 var sectioninfo;
	 var i, decimalscale, scaledvalue, strvalue, strparts, integervalue, fractionvalue;
	 var integerdigits2, integerpos, fractionpos, textcolor, textstyle, separatorchar, decimalchar;
	 var value; // working copy to change sign, etc.

	 rawvalue = rawvalue-0; // make sure a number
	 value = rawvalue;
	 if (!isFinite(value)) return "NaN";

	 var negativevalue = value < 0 ? 1 : 0; // determine sign, etc.
	 if (negativevalue) value = -value;
	 var zerovalue = value == 0 ? 1 : 0;

	 currency_char = currency_char || DefaultCurrency;

	 scfn.parse_format_string(scfn.format_definitions, format_string); // make sure format is parsed
	 thisformat = scfn.format_definitions[format_string]; // Get format structure

	 if (!thisformat) throw "Format not parsed error!";

	 section = thisformat.sectioninfo.length - 1; // get number of sections - 1

	 if (thisformat.hascomparison) { // has comparisons - determine which section
	     section = 0; // set to which section we will use
	     gotcomparison = 0; // this section has no comparison
	     for (cpos=0; ;cpos++) { // scan for comparisons
		 op = thisformat.operators[cpos];
		 operandstr = thisformat.operands[cpos]; // get next operator and operand
		 if (!op) { // at end with no match
		     if (gotcomparison) { // if comparison but no match
			 format_string = "General"; // use default of General
			 scfn.parse_format_string(scfn.format_definitions, format_string);
			 thisformat = scfn.format_definitions[format_string];
			 section = 0;
		     }
		     break; // if no comparision, matches on this section
		 }
		 if (op == scfn.commands.section) { // end of section
		     if (!gotcomparison) { // no comparison, so it's a match
			 break;
		     }
		     gotcomparison = 0;
		     section++; // check out next one
		     continue;
		 }
		 if (op == scfn.commands.comparison) { // found a comparison - do we meet it?
		     i=operandstr.indexOf(":");
		     compop=operandstr.substring(0,i);
		     compval=operandstr.substring(i+1)-0;
		     if ((compop == "<" && rawvalue < compval) ||
			 (compop == "<=" && rawvalue <= compval) ||
			 (compop == "=" && rawvalue == compval) ||
			 (compop == "<>" && rawvalue != compval) ||
			 (compop == ">=" && rawvalue >= compval) ||
			 (compop == ">" && rawvalue > compval)) { // a match
			     break;
		     }
		     gotcomparison = 1;
		 }
	     }
	 }
	 else if (section > 0) { // more than one section (separated by ";")
	     if (section == 1) { // two sections
		 if (negativevalue) {
		     negativevalue = 0; // sign will provided by section, not automatically
		     section = 1; // use second section for negative values
		 }
		 else {
		     section = 0; // use first for all others
		 }
	     }
	     else if (section == 2) { // three sections
		 if (negativevalue) {
		     negativevalue = 0; // sign will provided by section, not automatically
		     section = 1; // use second section for negative values
		 }
		 else if (zerovalue) {
		     section = 2; // use third section for zero values
		 }
		 else {
		     section = 0; // use first for positive
		 }
	     }
	 }

	 sectioninfo = thisformat.sectioninfo[section]; // look at values for our section

	 if (sectioninfo.commas > 0) { // scale by thousands
	     for (i=0; i<sectioninfo.commas; i++) {
		 value /= 1000;
	     }
	 }
	 if (sectioninfo.percent > 0) { // do percent scaling
	     for (i=0; i<sectioninfo.percent; i++) {
		 value *= 100;
	     }
	 }

	 decimalscale = 1; // cut down to required number of decimal digits
	 for (i=0; i<sectioninfo.fractiondigits; i++) {
	     decimalscale *= 10;
	 }
	 scaledvalue = Math.floor(value * decimalscale + 0.5);
	 scaledvalue = scaledvalue / decimalscale;

	 if (typeof scaledvalue != "number") return "NaN";
	 if (!isFinite(scaledvalue)) return "NaN";

	 strvalue = scaledvalue+""; // convert to string (Number.toFixed doesn't do all we need)

	 //   strvalue = value.toFixed(sectioninfo.fractiondigits); // cut down to required number of decimal digits
	 // and convert to string

	 if (scaledvalue == 0 && (sectioninfo.fractiondigits || sectioninfo.integerdigits)) {
	     negativevalue = 0; // no "-0" unless using multiple sections or General
	 }

	 if (strvalue.indexOf("e")>=0) { // converted to scientific notation
	     return rawvalue+""; // Just return plain converted raw value
	 }

	 strparts=strvalue.match(/^\+{0,1}(\d*)(?:\.(\d*)){0,1}$/); // get integer and fraction parts
	 if (!strparts) return "NaN"; // if not a number
	 integervalue = strparts[1];
	 if (!integervalue || integervalue=="0") integervalue="";
	 fractionvalue = strparts[2];
	 if (!fractionvalue) fractionvalue = "";

	 if (sectioninfo.hasdate) { // there are date placeholders
	     if (rawvalue < 0) { // bad date
		 return "??-???-??&nbsp;??:??:??";
	     }
	     startval = (rawvalue-Math.floor(rawvalue)) * SecondsInDay; // get date/time parts
	     estartval = rawvalue * SecondsInDay; // do elapsed time version, too
	     hrs = Math.floor(startval / SecondsInHour);
	     ehrs = Math.floor(estartval / SecondsInHour);
	     startval = startval - hrs * SecondsInHour;
	     mins = Math.floor(startval / 60);
	     emins = Math.floor(estartval / 60);
	     secs = startval - mins * 60;
	     decimalscale = 1; // round appropriately depending if there is ss.0
	     for (i=0; i<sectioninfo.fractiondigits; i++) {
		 decimalscale *= 10;
	     } 
	     secs = Math.floor(secs * decimalscale + 0.5);
	     secs = secs / decimalscale;
	     esecs = Math.floor(estartval * decimalscale + 0.5);
	     esecs = esecs / decimalscale;
	     if (secs >= 60) { // handle round up into next second, minute, etc.
		 secs = 0;
		 mins++; emins++;
		 if (mins >= 60) {
		     mins = 0;
		     hrs++; ehrs++;
		     if (hrs >= 24) {
			 hrs = 0;
			 rawvalue++;
		     }
		 }
	     }
	     fractionvalue = (secs-Math.floor(secs))+""; // for "hh:mm:ss.000"
	     fractionvalue = fractionvalue.substring(2); // skip "0."

	     ymd = workbook.FormatNumber.convert_date_julian_to_gregorian(Math.floor(rawvalue+JulianOffset));

	     minOK = 0; // says "m" can be minutes if true
	     mspos = sectioninfo.sectionstart; // m scan position in ops
	     for ( ; ; mspos++) { // scan for "m" and "mm" to see if any minutes fields, and am/pm
		 op = thisformat.operators[mspos];
		 operandstr = thisformat.operands[mspos]; // get next operator and operand
		 if (!op) break; // don't go past end
		 if (op==scfn.commands.section) break;
		 if (op==scfn.commands.date) {
		     if ((operandstr.toLowerCase()=="am/pm" || operandstr.toLowerCase()=="a/p") && !ampmstr) {
			 if (hrs >= 12) {
			     hrs -= 12;
			     ampmstr = operandstr.toLowerCase()=="a/p" ? PM1 : PM; // "P" : "PM";
			 }
			 else {
			     ampmstr = operandstr.toLowerCase()=="a/p" ? AM1 : AM; // "A" : "AM";
			 }
			 if (operandstr.indexOf(ampmstr)<0)
			     ampmstr = ampmstr.toLowerCase(); // have case match case in format
		     }
		     if (minOK && (operandstr=="m" || operandstr=="mm")) {
			 thisformat.operands[mspos] += "in"; // turn into "min" or "mmin"
		     }
		     if (operandstr.charAt(0)=="h") {
			 minOK = 1; // m following h or hh or [h] is minutes not months
		     }
		     else {
			 minOK = 0;
		     }
		 }
		 else if (op!=scfn.commands.copy) { // copying chars can be between h and m
		     minOK = 0;
		 }
	     }
	     minOK = 0;
	     for (--mspos; ; mspos--) { // scan other way for s after m
		 op = thisformat.operators[mspos];
		 operandstr = thisformat.operands[mspos]; // get next operator and operand
		 if (!op) break; // don't go past end
		 if (op==scfn.commands.section) break;
		 if (op==scfn.commands.date) {
		     if (minOK && (operandstr=="m" || operandstr=="mm")) {
			 thisformat.operands[mspos] += "in"; // turn into "min" or "mmin"
		     }
		     if (operandstr=="ss") {
			 minOK = 1; // m before ss is minutes not months
		     }
		     else {
			 minOK = 0;
		     }
		 }
		 else if (op!=scfn.commands.copy) { // copying chars can be between ss and m
		     minOK = 0;
		 }
	     }
	 }

	 integerdigits2 = 0; // init counters, etc.
	 integerpos = 0;
	 fractionpos = 0;
	 textcolor = "";
	 textstyle = "";
	 separatorchar = SeparatorChar;
	 if (separatorchar.indexOf(" ")>=0) separatorchar = separatorchar.replace(/ /g, "&nbsp;");
	 decimalchar = DecimalChar;
	 if (decimalchar.indexOf(" ")>=0) decimalchar = decimalchar.replace(/ /g, "&nbsp;");

	 oppos = sectioninfo.sectionstart;

	 while (op = thisformat.operators[oppos]) { // execute format
	     operandstr = thisformat.operands[oppos++]; // get next operator and operand

	     if (op == scfn.commands.copy) { // put char in result
		 result += operandstr;
	     }

	     else if (op == scfn.commands.color) { // set color
		 textcolor = operandstr;
	     }

	     else if (op == scfn.commands.style) { // set style
		 textstyle = operandstr;
	     }

	     else if (op == scfn.commands.integer_placeholder) { // insert number part
		 if (negativevalue) {
		     result += "-";
		     negativevalue = 0;
		 }
		 integerdigits2++;
		 if (integerdigits2 == 1) { // first one
		     if (integervalue.length > sectioninfo.integerdigits) { // see if integer wider than field
			 for (;integerpos < (integervalue.length - sectioninfo.integerdigits); integerpos++) {
			     result += integervalue.charAt(integerpos);
			     if (sectioninfo.thousandssep) { // see if this is a separator position
				 fromend = integervalue.length - integerpos - 1;
				 if (fromend > 2 && fromend % 3 == 0) {
				     result += separatorchar;
				 }
			     }
			 }
		     }
		 }
		 if (integervalue.length < sectioninfo.integerdigits
		     && integerdigits2 <= sectioninfo.integerdigits - integervalue.length) { // field is wider than value
		     if (operandstr == "0" || operandstr == "?") { // fill with appropriate characters
			 result += operandstr == "0" ? "0" : "&nbsp;";
			 if (sectioninfo.thousandssep) { // see if this is a separator position
			     fromend = sectioninfo.integerdigits - integerdigits2;
			     if (fromend > 2 && fromend % 3 == 0) {
				 result += separatorchar;
			     }
			 }
		     }
		 }
		 else { // normal integer digit - add it
		     result += integervalue.charAt(integerpos);
		     if (sectioninfo.thousandssep) { // see if this is a separator position
			 fromend = integervalue.length - integerpos - 1;
			 if (fromend > 2 && fromend % 3 == 0) {
			     result += separatorchar;
			 }
		     }
		     integerpos++;
		 }
	     }
	     else if (op == scfn.commands.fraction_placeholder) { // add fraction part of number
		 if (fractionpos >= fractionvalue.length) {
		     if (operandstr == "0" || operandstr == "?") {
			 result += operandstr == "0" ? "0" : "&nbsp;";
		     }
		 }
		 else {
		     result += fractionvalue.charAt(fractionpos);
		 }
		 fractionpos++;
	     }

	     else if (op == scfn.commands.decimal) { // decimal point
		 if (negativevalue) {
		     result += "-";
		     negativevalue = 0;
		 }
		 result += decimalchar;
	     }

	     else if (op == scfn.commands.currency) { // currency symbol
		 if (negativevalue) {
		     result += "-";
		     negativevalue = 0;
		 }
		 result += operandstr;
	     }

	     else if (op == scfn.commands.general) { // insert "General" conversion

		 // *** Cut down number of significant digits to avoid floating point artifacts:

		 if (value!=0) { // only if non-zero
		     var factor = Math.floor(Math.LOG10E * Math.log(value)); // get integer magnitude as a power of 10
		     factor = Math.pow(10, 13-factor); // turn into scaling factor
		     value = Math.floor(factor * value + 0.5)/factor; // scale positive value, round, undo scaling
		     if (!isFinite(value)) return "NaN";
		 }
		 if (negativevalue) {
		     result += "-";
		 }
		 strvalue = value+""; // convert original value to string
		 if (strvalue.indexOf("e")>=0) { // converted to scientific notation
		     result += strvalue;
		     continue;
		 }
		 strparts=strvalue.match(/^\+{0,1}(\d*)(?:\.(\d*)){0,1}$/); // get integer and fraction parts
		 integervalue = strparts[1];
		 if (!integervalue || integervalue=="0") integervalue="";
		 fractionvalue = strparts[2];
		 if (!fractionvalue) fractionvalue = "";
		 integerpos = 0;
		 fractionpos = 0;
		 if (integervalue.length) {
		     for (;integerpos < integervalue.length; integerpos++) {
			 result += integervalue.charAt(integerpos);
			 if (sectioninfo.thousandssep) { // see if this is a separator position
			     fromend = integervalue.length - integerpos - 1;
			     if (fromend > 2 && fromend % 3 == 0) {
				 result += separatorchar;
			     }
			 }
		     }
		 }
		 else {
		     result += "0";
		 }
		 if (fractionvalue.length) {
		     result += decimalchar;
		     for (;fractionpos < fractionvalue.length; fractionpos++) {
			 result += fractionvalue.charAt(fractionpos);
		     }
		 }
	     }
	     else if (op==scfn.commands.date) { // date placeholder
		 operandstrlc = operandstr.toLowerCase();
		 if (operandstrlc=="y" || operandstrlc=="yy") {
		     result += (ymd.year+"").substring(2);
		 }
		 else if (operandstrlc=="yyyy") {
		     result += ymd.year+"";
		 }
		 else if (operandstrlc=="d") {
		     result += ymd.day+"";
		 }
		 else if (operandstrlc=="dd") {
		     cval = 1000 + ymd.day;
		     result += (cval+"").substr(2);
		 }
		 else if (operandstrlc=="ddd") {
		     cval = Math.floor(rawvalue+6) % 7;
		     result += DayNames3[cval];
		 }
		 else if (operandstrlc=="dddd") {
		     cval = Math.floor(rawvalue+6) % 7;
		     result += DayNames[cval];
		 }
		 else if (operandstrlc=="m") {
		     result += ymd.month+"";
		 }
		 else if (operandstrlc=="mm") {
		     cval = 1000 + ymd.month;
		     result += (cval+"").substr(2);
		 }
		 else if (operandstrlc=="mmm") {
		     result += MonthNames3[ymd.month-1];
		 }
		 else if (operandstrlc=="mmmm") {
		     result += MonthNames[ymd.month-1];
		 }
		 else if (operandstrlc=="mmmmm") {
		     result += MonthNames[ymd.month-1].charAt(0);
		 }
		 else if (operandstrlc=="h") {
		     result += hrs+"";
		 }
		 else if (operandstrlc=="h]") {
		     result += ehrs+"";
		 }
		 else if (operandstrlc=="mmin") {
		     cval = (1000 + mins)+"";
		     result += cval.substr(2);
		 }
		 else if (operandstrlc=="mm]") {
		     if (emins < 100) {
			 cval = (1000 + emins)+"";
			 result += cval.substr(2);
		     }
		     else {
			 result += emins+"";
		     }
		 }
		 else if (operandstrlc=="min") {
		     result += mins+"";
		 }
		 else if (operandstrlc=="m]") {
		     result += emins+"";
		 }
		 else if (operandstrlc=="hh") {
		     cval = (1000 + hrs)+"";
		     result += cval.substr(2);
		 }
		 else if (operandstrlc=="s") {
		     cval = Math.floor(secs);
		     result += cval+"";
		 }
		 else if (operandstrlc=="ss") {
		     cval = (1000 + Math.floor(secs))+"";
		     result += cval.substr(2);
		 }
		 else if (operandstrlc=="am/pm" || operandstrlc=="a/p") {
		     result += ampmstr;
		 }
		 else if (operandstrlc=="ss]") {
		     if (esecs < 100) {
			 cval = (1000 + Math.floor(esecs))+"";
			 result += cval.substr(2);
		     }
		     else {
			 cval = Math.floor(esecs);
			 result += cval+"";
		     }
		 }
	     }
	     else if (op == scfn.commands.section) { // end of section
		 break;
	     }

	     else if (op == scfn.commands.comparison) { // ignore
		 continue;
	     }

	     else {
		 result += "!! Parse error !!";
	     }
	 }

	 if (textcolor) {
	     result = '<span style="color:'+textcolor+';">'+result+'</span>';
	 }
	 if (textstyle) {
	     result = '<span style="'+textstyle+';">'+result+'</span>';
	 }

	 return result;

     };

     /* *******************

	workbook.FormatNumber.parse_format_string(format_defs, format_string)

	Takes a format string (e.g., "#,##0.00_);(#,##0.00)") and fills in format_defs with the parsed info

	format_defs
	["#,##0.0"]->{} - elements in the hash are one hash for each format
	.operators->[] - array of operators from parsing the format string (each a number)
	.operands->[] - array of corresponding operators (each usually a string)
	.sectioninfo->[] - one hash for each section of the format
	.start
	.integerdigits
	.fractiondigits
	.commas
	.percent
	.thousandssep
	.hasdates
	.hascomparison - true if any section has [<100], etc.

	,************************* */

     workbook.FormatNumber.parse_format_string = function(format_defs, format_string) {

	 var scfn = workbook.FormatNumber;

	 var thisformat, section, sectionfinfo;
	 var integerpart = 1; // start out in integer part
	 var lastwasinteger; // last char was an integer placeholder
	 var lastwasslash; // last char was a backslash - escaping following character
	 var lastwasasterisk; // repeat next char
	 var lastwasunderscore; // last char was _ which picks up following char for width
	 var inquote, quotestr; // processing a quoted string
	 var inbracket, bracketstr, bracketdata; // processing a bracketed string
	 var ingeneral, gpos; // checks for characters "General"
	 var ampmstr, part; // checks for characters "A/P" and "AM/PM"
	 var indate; // keeps track of date/time placeholders
	 var chpos; // character position being looked at
	 var ch; // character being looked at

	 if (format_defs[format_string]) return; // already defined - nothing to do

	 thisformat = {operators: [], operands: [], sectioninfo: [{}]}; // create info structure for this format
	 format_defs[format_string] = thisformat; // add to other format definitions

	 section = 0; // start with section 0
	 sectioninfo = thisformat.sectioninfo[section]; // get reference to info for current section
	 sectioninfo.sectionstart = 0; // position in operands that starts this section
	 sectioninfo.integerdigits = 0; // number of integer-part placeholders
	 sectioninfo.fractiondigits = 0; // fraction placeholders
	 sectioninfo.commas = 0; // commas encountered, to handle scaling
	 sectioninfo.percent = 0; // times to scale by 100

	 for (chpos=0; chpos<format_string.length; chpos++) { // parse
	     ch = format_string.charAt(chpos); // get next char to examine
	     if (inquote) {
		 if (ch == '"') {
		     inquote = 0;
		     thisformat.operators.push(scfn.commands.copy);
		     thisformat.operands.push(quotestr);
		     continue;
		 }
		 quotestr += ch;
		 continue;
	     }
	     if (inbracket) {
		 if (ch==']') {
		     inbracket = 0;
		     bracketdata=workbook.FormatNumber.parse_format_bracket(bracketstr);
		     if (bracketdata.operator==scfn.commands.separator) {
			 sectioninfo.thousandssep = 1; // explicit [,]
			 continue;
		     }
		     if (bracketdata.operator==scfn.commands.date) {
			 sectioninfo.hasdate = 1;
		     }
		     if (bracketdata.operator==scfn.commands.comparison) {
			 thisformat.hascomparison = 1;
		     }
		     thisformat.operators.push(bracketdata.operator);
		     thisformat.operands.push(bracketdata.operand);
		     continue;
		 }
		 bracketstr += ch;
		 continue;
	     }
	     if (lastwasslash) {
		 thisformat.operators.push(scfn.commands.copy);
		 thisformat.operands.push(ch);
		 lastwasslash=false;
		 continue;
	     }
	     if (lastwasasterisk) {
		 thisformat.operators.push(scfn.commands.copy);
		 thisformat.operands.push(ch+ch+ch+ch+ch); // do 5 of them since no real tabs
		 lastwasasterisk=false;
		 continue;
	     }
	     if (lastwasunderscore) {
		 thisformat.operators.push(scfn.commands.copy);
		 thisformat.operands.push("&nbsp;");
		 lastwasunderscore=false;
		 continue;
	     }
	     if (ingeneral) {
		 if ("general".charAt(ingeneral)==ch.toLowerCase()) {
		     ingeneral++;
		     if (ingeneral == 7) {
			 thisformat.operators.push(scfn.commands.general);
			 thisformat.operands.push(ch);
			 ingeneral=0;
		     }
		     continue;
		 }
		 ingeneral = 0;
	     }
	     if (indate) { // last char was part of a date placeholder
		 if (indate.charAt(0)==ch) { // another of the same char
		     indate += ch; // accumulate it
		     continue;
		 }
		 thisformat.operators.push(scfn.commands.date); // something else, save date info
		 thisformat.operands.push(indate);
		 sectioninfo.hasdate=1;
		 indate = "";
	     }
	     if (ampmstr) {
		 ampmstr += ch;
		 part=ampmstr.toLowerCase();
		 if (part!="am/pm".substring(0,part.length) && part!="a/p".substring(0,part.length)) {
		     ampstr="";
		 }
		 else if (part=="am/pm" || part=="a/p") {
		     thisformat.operators.push(scfn.commands.date);
		     thisformat.operands.push(ampmstr);
		     ampmstr = "";
		 }
		 continue;
	     }
	     if (ch=="#" || ch=="0" || ch=="?") { // placeholder
		 if (integerpart) {
		     sectioninfo.integerdigits++;
		     if (sectioninfo.commas) { // comma inside of integer placeholders
			 sectioninfo.thousandssep = 1; // any number is thousands separator
			 sectioninfo.commas = 0; // reset count of "thousand" factors
		     }
		     lastwasinteger = 1;
		     thisformat.operators.push(scfn.commands.integer_placeholder);
		     thisformat.operands.push(ch);
		 }
		 else {
		     sectioninfo.fractiondigits++;
		     thisformat.operators.push(scfn.commands.fraction_placeholder);
		     thisformat.operands.push(ch);
		 }
	     }
	     else if (ch==".") { // decimal point
		 lastwasinteger = 0;
		 thisformat.operators.push(scfn.commands.decimal);
		 thisformat.operands.push(ch);
		 integerpart = 0;
	     }
	     else if (ch=='$') { // currency char
		 lastwasinteger = 0;
		 thisformat.operators.push(scfn.commands.currency);
		 thisformat.operands.push(ch);
	     }
	     else if (ch==",") {
		 if (lastwasinteger) {
		     sectioninfo.commas++;
		 }
		 else {
		     thisformat.operators.push(scfn.commands.copy);
		     thisformat.operands.push(ch);
		 }
	     }
	     else if (ch=="%") {
		 lastwasinteger = 0;
		 sectioninfo.percent++;
		 thisformat.operators.push(scfn.commands.copy);
		 thisformat.operands.push(ch);
	     }
	     else if (ch=='"') {
		 lastwasinteger = 0;
		 inquote = 1;
		 quotestr = "";
	     }
	     else if (ch=='[') {
		 lastwasinteger = 0;
		 inbracket = 1;
		 bracketstr = "";
	     }
	     else if (ch=='\\') {
		 lastwasslash = 1;
		 lastwasinteger = 0;
	     }
	     else if (ch=='*') {
		 lastwasasterisk = 1;
		 lastwasinteger = 0;
	     }
	     else if (ch=='_') {
		 lastwasunderscore = 1;
		 lastwasinteger = 0;
	     }
	     else if (ch==";") {
		 section++; // start next section
		 thisformat.sectioninfo[section] = {}; // create a new section
		 sectioninfo = thisformat.sectioninfo[section]; // get reference to info for current section
		 sectioninfo.sectionstart = 1 + thisformat.operators.length; // remember where it starts
		 sectioninfo.integerdigits = 0; // number of integer-part placeholders
		 sectioninfo.fractiondigits = 0; // fraction placeholders
		 sectioninfo.commas = 0; // commas encountered, to handle scaling
		 sectioninfo.percent = 0; // times to scale by 100
		 integerpart = 1; // reset for new section
		 lastwasinteger = 0;
		 thisformat.operators.push(scfn.commands.section);
		 thisformat.operands.push(ch);
	     }
	     else if (ch.toLowerCase()=="g") {
		 ingeneral = 1;
		 lastwasinteger = 0;
	     }
	     else if (ch.toLowerCase()=="a") {
		 ampmstr = ch;
		 lastwasinteger = 0;
	     }
	     else if ("dmyhHs".indexOf(ch)>=0) {
		 indate = ch;
	     }
	     else {
		 lastwasinteger = 0;
		 thisformat.operators.push(scfn.commands.copy);
		 thisformat.operands.push(ch);
	     }
	 }

	 if (indate) { // last char was part of unsaved date placeholder
	     thisformat.operators.push(scfn.commands.date);
	     thisformat.operands.push(indate);
	     sectioninfo.hasdate = 1;
	 }

	 return;

     }


     /* *******************

	bracketdata = workbook.FormatNumber.parse_format_bracket(bracketstr)

	Takes a bracket contents (e.g., "RED", ">10") and returns an operator and operand

	bracketdata->{}
	.operator
	.operand

	,************************* */

     workbook.FormatNumber.parse_format_bracket = function(bracketstr) {

	 var scfn = workbook.FormatNumber;

	 var bracketdata={};
	 var parts;

	 if (bracketstr.charAt(0)=='$') { // currency
	     bracketdata.operator = scfn.commands.currency;
	     parts=bracketstr.match(/^\$(.+?)(\-.+?){0,1}$/);
	     if (parts) {
		 bracketdata.operand = parts[1] || DefaultCurrency || '$';
	     }
	     else {
		 bracketdata.operand = bracketstr.substring(1) || DefaultCurrency || '$';
	     }
	 }
	 else if (bracketstr=='?$') {
	     bracketdata.operator = scfn.commands.currency;
	     bracketdata.operand = '[?$]';
	 }
	 else if (AllowedColors[bracketstr.toUpperCase()]) {
	     bracketdata.operator = scfn.commands.color;
	     bracketdata.operand = AllowedColors[bracketstr.toUpperCase()];
	 }
	 else if (parts=bracketstr.match(/^style=([^"]*)$/)) { // [style=...]
	     bracketdata.operator = scfn.commands.style;
	     bracketdata.operand = parts[1];
	 }
	 else if (bracketstr==",") {
	     bracketdata.operator = scfn.commands.separator;
	     bracketdata.operand = bracketstr;
	 }
	 else if (AllowedDates[bracketstr.toUpperCase()]) {
	     bracketdata.operator = scfn.commands.date;
	     bracketdata.operand = AllowedDates[bracketstr.toUpperCase()];
	 }
	 else if (parts=bracketstr.match(/^[<>=]/)) { // comparison operator
	     parts=bracketstr.match(/^([<>=]+)(.+)$/); // split operator and value
	     bracketdata.operator = scfn.commands.comparison;
	     bracketdata.operand = parts[1]+":"+parts[2];
	 }
	 else { // unknown bracket
	     bracketdata.operator = scfn.commands.copy;
	     bracketdata.operand = "["+bracketstr+"]";
	 }

	 return bracketdata;

     }

     /* *******************

	juliandate = workbook.FormatNumber.convert_date_gregorian_to_julian(year, month, day)

	From: http://aa.usno.navy.mil/faq/docs/JD_Formula.html
	Uses: Fliegel, H. F. and van Flandern, T. C. (1968). Communications of the ACM, Vol. 11, No. 10 (October, 1968).
	Translated from the FORTRAN

	I= YEAR
	J= MONTH
	K= DAY
	C
	JD= K-32075+1461*(I+4800+(J-14)/12)/4+367*(J-2-(J-14)/12*12)
	2    /12-3*((I+4900+(J-14)/12)/100)/4

	,************************* */

     workbook.FormatNumber.convert_date_gregorian_to_julian = function(year, month, day) {

	 var juliandate;

	 juliandate = day-32075+workbook.intFunc(1461*(year+4800+workbook.intFunc((month-14)/12))/4);
	 juliandate += workbook.intFunc(367*(month-2-workbook.intFunc((month-14)/12)*12)/12);
	 juliandate = juliandate - workbook.intFunc(3*workbook.intFunc((year+4900+workbook.intFunc((month-14)/12))/100)/4);

	 return juliandate;

     }


     /* *******************

	ymd = workbook.FormatNumber.convert_date_julian_to_gregorian(juliandate)

	ymd->{}
	.year
	.month
	.day

	From: http://aa.usno.navy.mil/faq/docs/JD_Formula.html
	Uses: Fliegel, H. F. and van Flandern, T. C. (1968). Communications of the ACM, Vol. 11, No. 10 (October, 1968).
	Translated from the FORTRAN

	,************************* */

     workbook.FormatNumber.convert_date_julian_to_gregorian = function(juliandate) {

	 var L, N, I, J, K;

	 L = juliandate+68569;
	 N = Math.floor(4*L/146097);
	 L = L-Math.floor((146097*N+3)/4);
	 I = Math.floor(4000*(L+1)/1461001);
	 L = L-Math.floor(1461*I/4)+31;
	 J = Math.floor(80*L/2447);
	 K = L-Math.floor(2447*J/80);
	 L = Math.floor(J/11);
	 J = J+2-12*L;
	 I = 100*(N-49)+I+L;

	 return {year:I, month:J, day:K};

     }

     workbook.intFunc = function(n) {
	 if (n < 0) {
	     return -Math.floor(-n);
	 }
	 else {
	     return Math.floor(n);
	 }
     }
   #+END_SRC
 
** heartbeat
   
   #+BEGIN_SRC js
     workbook.start = new Date();
     workbook.beat = 0;

     workbook.heartbeat = function() {
         workbook.beat++;
     }

     setInterval(workbook.loop, 50);
   #+END_SRC
   
** hit
   
   Check if cell is found within range.
   
   #+BEGIN_SRC js
     workbook.hit = function(range, addr) {      
         return range.hit(addr);
     }
   #+END_SRC

** lookupFormulaId

   #+BEGIN_SRC js
     // todo: make sure that formula lookup ignores leading "="
     workbook.prototype.lookupFormulaId = function(exp) {
         if (typeof exp !== "string") {
             throw Error("Formula lookup key must be string");
         }

         if (exp[0] === "=") {
             exp = exp.substr(1);
         }
         
         if (this.functionLookup.hasOwnProperty(exp)) {
             return this.functionLookup[exp];
         }
     }   
   #+END_SRC

** makeFunction
   
   Convert a formula into a function.
   
   #+BEGIN_SRC js
     workbook.makeFunction = function(name, args, exp) {
	 if (typeof name === 'undefined') throw Error("Must provide name to make formula");
	 if (typeof exp === 'undefined') { // handle overload for (name, exp)
	     exp = args;
	     args = "";
	 }
	 fn[name] = Function("return " + workbook.compile(exp, 2) + ";");
     }
   #+END_SRC
   
** nameRange
   
   Add lookup and reverse lookup for cell names.
   
   #+BEGIN_SRC js

     workbook.prototype.nameRange = function(name, ref) {
         var parts;
         if (ref.indexOf('!') > 0) {
             parts = workbook.splitReference(ref);

             if (parts.length !== 2) {
                 throw Error("Expect two parts in ref");
             }
             
             sheetIndex = this.resolveSheet(parts[0]);
             this.namedRange[name] = this.ref(sheetIndex, parts[1]);
             
         } else {
             throw Error("Expected format Sheet!Ref");
         }
         
         return this;
     }
        
   #+END_SRC
   
** on
   
   A function to register a callback on a workbook.
   
   #+BEGIN_SRC js
     // register a callback on an event
     workbook.prototype.on = function(eventName, cb) {
	 if (this.callbacks.hasOwnProperty(eventName)) {
	     this.callbacks[eventName].push(cb);
	 } else {
	     throw Error("Unknown event: " + eventName);
	 }
     }    
   #+END_SRC
   
** parse
   
   The parse function converts an expression into an abstract syntax tree (AST).
   
   #+BEGIN_SRC js
     workbook.parse = function(context, exp) {
         if (typeof exp === 'undefined' && typeof context === 'string') {
             exp = context;
             context = {}
         } else if (typeof exp === 'undefined') {
             throw TypeError("No formula!");
         }

         if (typeof context !== 'object' && typeof context !== 'function') {
             throw TypeError("Context must be an object or a function!");
         }

         parser.yy.context = context;

         return parser.parse(exp);
     };

   #+END_SRC
   
** populateGraph

   Populates the graph with the precedents of a function.

   #+BEGIN_SRC js
     workbook.prototype.populateGraph = function(dep, f) {
         // push the precedents into the graph
         for (var i = 0; i < f.context.precedents.length; i++) {
             this.graph.push([dep, f.context.precedents[i]]);
         }
     }
   #+END_SRC

** removeNamedRange
   
   Removes a named range from the workbook.
   
   #+BEGIN_SRC js
     workbook.prototype.removeNamedRange = function(name) {

	 if (!this.namedRange.hasOwnProperty(name)) {
	     return this; // name doesn't exist.
	 }
	 
	 var ref =  this.namedRange[name];
	 
	 delete this.namedRange[name];
     }
   #+END_SRC
   
** range

   Returns a range object given a sheet reference and an expression.

   #+BEGIN_SRC js
     workbook.prototype.range = function(sheetRef, topLeft, bottomRight) {
         var index = this.resolveSheet(sheetRef);
             
         if (arguments.length === 2) {
             r = this.ref(index, topLeft);
         } else if (arguments.length === 3) {
             r = new range(this, index, this.cell(index, topLeft), this.cell(index, bottomRight));
         } else {
             throw Error("Unexpected usage.");
         }

         return r;
     }
   #+END_SRC

** recalculate

   #+BEGIN_SRC js
     workbook.prototype.recalculate = function(sheetIndex, cellIndex) {
         var fid = this.cell[sheetIndex][cellIndex].fid;
         var f = this.functions[fid];

         if (!f) {
             return error.na;
         }

         return this.run(sheetIndex, f);
     }
   #+END_SRC

** resolveCell

   Resolve cell of function into cell reference.

   #+BEGIN_SRC js
     workbook.resolveCell = function(ref) {
         if (fn.ISCELL(ref)) {
             return ref;
         } else if (typeof ref === 'function') {
             return ref();
         } else {
             throw Error("Expects cell or function");
         }
     }      
   #+END_SRC

** resolveSheet

   #+BEGIN_SRC js
     workbook.prototype.resolveSheet = function(sheetRef) {
         var sheetIndex;
         if (fn.ISNUMBER(sheetRef)) {
             return sheetRef; // short circuit
         } else if (fn.ISTEXT(sheetRef)) { // sheet name to index
             sheetIndex = this.sheetNames.indexOf(sheetRef);
         } else if (fn.ISOBJECT(sheetRef)) { // sheet object to index
             sheetIndex = this.sheets.indexOf(sheetRef);
         }
         
         // ensure correct resolution
         if (typeof sheetIndex === "undefined" ) {
             throw Error("Sheet index is undefined");
         }
         
         if ( sheetIndex < 0 ) {
             throw Error("Sheet index is negative");
         }

         return sheetIndex;
         
     }
   #+END_SRC

** ref

   #+BEGIN_SRC js
     // Get the col and row for a cell (e.g. A1 or $A$1).
     workbook.prototype.ref = function(sheetIndex, ref) {
         var result;
         
         if (!ref) { throw Error("ref is undefined"); }

         // handle named ranges and references that are cell objects
         if (this.namedRange.hasOwnProperty(ref)) {
             return this.namedRange[ref];
         } else if (fn.ISCELL(cell)) {
             ref = cell.addr;
         }

         if (ref.indexOf(':') >= 0) { // handle ranges
             parts = ref.split(':');
             if (parts.length !== 2) { throw Error("parts should have 2 length."); }
             result = new range(this, sheetIndex, this.ref(sheetIndex, parts[0]), this.ref(sheetIndex, parts[1]));

         } else { // handle cells

             result = this.cell(sheetIndex, ref);
         }

         return result;
     }
        
   #+END_SRC

** run
   
   The run function compiles an expression and evaluates the result.
   
   #+BEGIN_SRC js
     workbook.run = workbook.prototype.run = function(sheetRef, exp) {            
         var f,
             context={ workbook: this, precedents: [] },
             index;

         // handle case when only 1 argument is passed to function
         if (arguments.length === 1) {

             if (typeof sheetRef !== "string") {
                 throw new Error("Argument must be string if only 1 argument is passed to workbook.run");
             }
             
             exp = sheetRef;
             context.sheet = {};
         } else {
             index = this.resolveSheet(sheetRef);
             context.sheet = this.sheets[index];
             context.sheetName = this.sheetNames[index];
             context.sheetIndex = index;
         }


         context.range = function(topLeft, bottomRight) {         
            var r = new range(context.workbook, context.sheetIndex, topLeft, bottomRight);
	    if (r.dynamic) {
		this.workbook.dynamicranges.push(r);
	    }
            this.precedents.push(r);
            return r;
         }

         context.ref = function() {
             var sheetName, addr, ref, parts;
             if (arguments.length === 2) {
                 sheetName = arguments[0];
                 addr = arguments[1];
                 ref = this.workbook.ref(sheetName, addr);
             } else {
                 addr = arguments[0];
                 ref = this.workbook.ref(context.sheetIndex, addr);
             }

             this.precedents.push(ref);
             return ref;
         }

         if (typeof exp === "string") { 

             if (this.constructor.name === "workbook") {
                 f = this.lookupFormulaId(exp);
                 
                 if (!f) {
                     f = workbook.compile.apply(context, [exp]);

                     if (exp[0] === "=") {
                         exp = exp.substr(1);
                     }
                     
                     // Intentional programming chases its own tail.
                     // the ref to a definition of a set of rules
                     this.functions[f.id] = f;

                     // index for faster access
                     this.functionLookup[exp] = f.id;

                 } else {
                     f = this.functions[f];
                 }
             } else { // always compile when constructor not workbook
                 f = workbook.compile.apply(context, [exp]);
             }

         } else if (typeof exp === "function") {
             f = exp;
         } else {
             throw Error("exp expected to be string or function");
         }

         f.context = context;
         return f(context);
     };   

   #+END_SRC

** sheet
   
   #+BEGIN_SRC js

     function autoName(wb) {
         return "Sheet" + (wb.sheets.length + 1);
     }

     function autoSheet(store) {
         switch(store) {
         case "col":
         case "row":
             return [];
             break;
         default:
             return {}
             break;
         }
     }

     workbook.prototype.sheet = function(config) {
         var index = this.sheets.length, ws, name, wb = this, store = "object";

         
         if (config) {
             if (config.hasOwnProperty("name")) {
                 name = config.name;
             } else {
                 name = autoName(this);
             }

             if (config.hasOwnProperty("store")) {
                 store = config.store;
             }
             
             if (config.hasOwnProperty("data")) {
                 ws = config.data;
             } else {
                 ws = autoSheet(store);
             }


         } else {
             name = autoName(this);
             ws = autoSheet();
         }
         
         this.sheetNames.push(name);
         this.sheets.push(ws);
         this.sheetStore[index] = store;
         this.cells[index] = [ ];

         return ws;

     }
   #+END_SRC
   
** sheetName
   
   Returns the fully qualified worksheet name.
   
   #+BEGIN_SRC js
     workbook.sheetName = function(name, cell) {
         return ((name.indexOf(' ') > 0 ?
                  ("'" + name + "'!" + cell) :
                  (name + "!" + cell)));
         
     }

   #+END_SRC

** splitReference
   
   #+BEGIN_SRC js
     // A function to split Sheet!Cell or Sheet!Ref into 2 parts
     workbook.splitReference = function(ref) {
         var parts = [], worksheet;
         
         if (typeof ref !== "string") {
             throw "expects string";
         }

         parts = ref.split('!');

         if (parts.length !== 2) {
             throw "reference should have two parts";
         }
         
         worksheet = parts[0];

         // strip leading and trailing ' if present
         if (worksheet.indexOf("'") === 0) {
             parts[0] = worksheet.substring(1, worksheet.length-1);
         }

         return parts;
         
     }     
   #+END_SRC
   
** set
   
   Set a value in a worksheet.

   This function has three forms:
   
   1. Batch Form: *set(ws, batch_set_object)*
   2. Reference Form: *set(ws, ref, value)*
   3. Index Form: *set(ws, row, col, value)*
   
   #+BEGIN_SRC js

     workbook.prototype.set = function() {
         var ws, wsName, ref, row, col, value, ci, sheetIndex, oldValue, exp;

         if (arguments.length < 2 || arguments.length > 4) {
             throw Error("set expects 2..4 arguments. actual: " + arguments.length);
         }

         sheetIndex = this.resolveSheet(arguments[0]);


         if (arguments.length === 2) {

             for (var key in arguments[1]) {
                 this.set(sheetIndex, key, arguments[1][key]);
             }

             return;
             
         } else if (arguments.length === 3) {
             
             ref = arguments[1];
             value = arguments[2];

             // handle named ranges
             if (typeof ref === "number") {
                 ref = new cell(this, sheetIndex, ref);
             } else {
                 if (this.namedRange.hasOwnProperty(ref)) {
                     ref = this.namedRange[ref];
                 } else {
                     ref = this.ref(sheetIndex, ref);
                 }

                 if (fn.ISRANGE(ref)) {
                     ref.set(value);
                     return;
                 }
             }
             
         } else if (arguments.length === 4) {
             row = arguments[1];
             col = arguments[2];
             value = arguments[3];

             ref = new cell(this, sheetIndex, row, col);
         }
         
         if (typeof value === "string" && value[0] === "=") {
             exp = value;
             value = this.setFormula(sheetIndex, ref, exp);
         } 
         
         oldValue = this.setValue(sheetIndex, ref, value);
         this.triggerEvent("set", [this.sheetNames[sheetIndex], ref, oldValue, value]);
         
         this.update( sheetIndex, ref );

         return this;
     };
   #+END_SRC
   
** setFormula

   #+BEGIN_SRC js
     workbook.prototype.setFormula = function(sheetIndex, ref, exp) {
         var ref, addr,
             f, cellIndex = ref.cellIndex;
         
         // run the expression
         var result = this.run(this.sheets[sheetIndex], exp);

         f = this.lookupFormulaId(exp);
         if ( typeof f === "number" ) {
             this.cells[sheetIndex][cellIndex].fid = f;
         } else {
             throw Error("Cannot find function for exp: " + exp);
         }

         return result;
     }   
   #+END_SRC

** setValue

   #+BEGIN_SRC js
     // row and col expected in 0 base. first column is 0 and first row is 0.
     workbook.prototype.setValue = function(sheetIndex, cell, value) {
         var col = cell.colIndex,
             row = cell.rowIndex;
         
         if (row >= MAX_ROWS) {
             throw Error("Exceeds maximum row");
         }

         if (col >= MAX_COLS) {
             throw Error("Exceeds maximum col");
         }
         
         var ws = this.sheets[sheetIndex], oldValue, addr;

         switch(this.sheetStore[sheetIndex]) {
         case "col":
             if (!ws[col]) { ws[col] = []; }
             oldValue = ws[col][row];
             ws[col][row] = value;
             break;
         case "row":
             if (!ws[row]) { ws[row] = []; }
             oldValue = ws[row][col]
             ws[row][col] = value;
             break;
         default:
             addr = cell.addr();
             oldValue = ws[addr];
             ws[addr] = value;
         }    
         

         return oldValue;
         
     }   
   #+END_SRC
   
** toColumn
   
   Converts a column index (26) into the column (e.g. A or AB).
   
   #+BEGIN_SRC js
     var toColumnMem = {};
     workbook.toColumn = function( column_index ) {

	 if (toColumnMem.hasOwnProperty(column_index)) {
	     return toColumnMem[ column_index ];
	 }
	 
	 // The column is determined by applying a modified Hexavigesimal algorithm.
	 // Normally BA follows Z but spreadsheets count wrong and nobody cares. 

	 // Instead they do it in a way that makes sense to most people but
	 // is mathmatically incorrect. So AA follows Z which in the base 10
	 // system is like saying 01 follows 9. 

	 // In the least significant digit
	 // A..Z is 0..25

	 // For the second to nth significant digit
	 // A..Z is 1..26

	 var converted = ""
	 ,secondPass = false
	 ,remainder;

	 value = Math.abs(column_index);
	 
	 do {
	     remainder = value % 26;

	     if (secondPass) {
		 remainder--;
	     }
	     
	     converted = String.fromCharCode((remainder + 'A'.charCodeAt(0))) + converted;
	     value = Math.floor((value - remainder) / 26);

	     secondPass = true;
	 } while (value > 0);

	 toColumnMem[ column_index ] = converted;    
	 return converted;
     }

   #+END_SRC

** toColumnIndex

   Convert column name back to the column index.

   #+BEGIN_SRC js
     // Many thanks to http://en.wikipedia.org/wiki/Hexavigesimal for explaining the number theory
     // and the basic structure of the algorithm (modified base26).
     workbook.toColumnIndex = function(column) {

         // convert the column name into the column index

         // see toColumn for rant on why this is sensible even though it is illogical.
         var s = 0, secondPass;

         if (column != null && column.length > 0) {

             s = column.charCodeAt(0) - 'A'.charCodeAt(0);
             
             for (var i = 1; i < column.length; i++) {
                 s+=1 // compensate for the weirdos that invented spreadsheet column naming
                 s *= 26;
                 s += column.charCodeAt(i) - 'A'.charCodeAt(0);
                 secondPass = true;
             }
             
         } else {
             throw Error("Must provide a column");
         }

         return s;

     }
   #+END_SRC
   
** triggerEvent
   
   Triggers event callbacks when an action is performed on a worksheet.
   
   #+BEGIN_SRC js
     // invokes all of the callbacks registered by callers
     workbook.prototype.triggerEvent = function(eventName, args) {
         this.callbacks[eventName].forEach(function(cb) {
             cb.apply(this, args); 
         });
     }     
   #+END_SRC
   
** update

   #+BEGIN_SRC js
     workbook.prototype.update = function(sheetIndex, cell) {
         var cellIndex = cell.cellIndex,
             rowIndex = cell.rowIndex,
             colIndex = cell.colIndex;
             dirtyCells = this.findDependents(sheetIndex, cell);

         if (dirtyCells) {
             for(var i = 0; i < dirtyCells.length; i++) {
                 cellToUpdate = dirtyCells[i];

                 oldValue = this.getValue(sheetIndex, rowIndex, colIndex);
                 newValue = this.recalculate(sheetIndex, cellIndex);
                 
                 if (oldValue !== newValue) {

                     if (fn.ISCELL(newValue) || oldValue !== newValue.valueOf()) {
                         this.set(sheetIndex,
                                  rowIndex,
                                  colIndex,
                                  newValue.valueOf());
                         
                         // Trigger notification on the callbacks
                         this.triggerEvent("updated",
                                           [sheetIndex,
                                            rowIndex,
                                            colIndex,
                                            newValue,
                                            oldValue]);

                     }
                 }
             }
         }
     }
   #+END_SRC

** wrapString

   #+BEGIN_SRC js
     workbook.wrapString = function(s) {

         if (s[0] == "'" && s[s.length-1] === "'") {
             return s;
         }
         
         return 'String(' + s + '.valueOf())';

     }
   #+END_SRC

* Cell Code 							   :noexport:
  :PROPERTIES:
  :noweb-ref: CellModel
  :END:

  A cell is an abstraction for a value that is set with a value or a formula.

   #+BEGIN_SRC js
     function cell(wb, sheetIndex) {
         var cellIndex, addr, rowIndex, colIndex;

         if (arguments.length === 3) {
             cellIndex = arguments[2];
             var addr = INDEX2ADDR(cellIndex);
             rowIndex = addr.rowIndex;
             colIndex = addr.colIndex;
             
         } else if (arguments.length === 4) {
             rowIndex = arguments[2];
             colIndex = arguments[3];
             cellIndex = CELLINDEX( rowIndex, colIndex );
         }
         
         if (wb.cells[sheetIndex][cellIndex]) {
             return wb.cells[sheetIndex][cellIndex];
         } else {

             this.workbook = wb;
             this.sheetIndex = sheetIndex;
             this.cellIndex = cellIndex;
             this.rowIndex = rowIndex;
             this.colIndex = colIndex;
             
             wb.cells[sheetIndex][cellIndex] = this;
             
             return this;
         }
     };

     cell.prototype.valueOf = cell.prototype.val = cell.prototype.value = function() {
         return this.workbook.getValue(this.sheetIndex,
                                       this.rowIndex,
                                       this.colIndex);
     };

     cell.prototype.addr = function() {
         return fn.ADDRESS(this.rowIndex+1, this.colIndex+1, 0);
     }

     cell.prototype.toString = function() {
         return workbook.sheetName(this.sheetName, this.addr());
     };
   #+END_SRC  
   
* Range Code 							   :noexport:
  :PROPERTIES:
  :noweb-ref:    RangeModel
  :END:

  A range is an abstraction for a portion of a worksheet.

** Constructor

   #+BEGIN_SRC js
     function range(wb, sheetIndex, topLeft, bottomRight) {

         // link back to workbook
         this.workbook = wb;

         // the sheet on which the range is set.
         this.sheetIndex = sheetIndex;
         
         if (topLeft.cellIndex > bottomRight.cellIndex) {
             throw Error("topLeft must be smaller then bottomRight");
         }
         
         if (typeof topLeft !== 'function' && !fn.ISCELL(topLeft)) {
             throw Error("topLeft must be function or reference");
         }

         if (typeof bottomRight !== 'function' && !fn.ISREF(bottomRight)) {
             throw Error("bottomRight must be function or reference");
         }

         if (fn.ISFUNCTION(topLeft) || fn.ISFUNCTION(bottomRight)) {
             this.dynamic = true;
             this.topLeft = topLeft;
             this.bottomRight = bottomRight;
             return this;
         } else {
             this.dynamic = false;
             
             // combine cellIndexes to get a unique key for ranges.
             this.rangeIndex = topLeft.cellIndex + bottomRight.cellIndex;
         }


         // if already created then return it from the index.
         if (wb.rangeLookup[sheetIndex] &&
             wb.rangeLookup[sheetIndex][this.rangeIndex]) {
             var rangeId = wb.rangeLookup[sheetIndex][this.rangeIndex];
             return wb.ranges[rangeId];
         }
             
         this.rangeId = wb.ranges.length;
         this.sheetIndex = topLeft.sheetIndex;
         this.topLeft = topLeft;
         this.bottomRight = bottomRight;

         if (!wb.rangeLookup[sheetIndex]) {
              wb.rangeLookup[sheetIndex] = [];
         }
         
         wb.rangeLookup[sheetIndex][this.rangeIndex] = this.rangeId;
         wb.ranges[this.rangeId] = this;
         
         return this;
     }   
   #+END_SRC

** cells

  #+BEGIN_SRC js

    range.prototype.cells = function(mode) {
        var a,b, sheetIndex, wb;                             
        
        a = workbook.resolveCell(this.topLeft);
        b = workbook.resolveCell(this.bottomRight);    

        if (a.sheetIndex !== b.sheetIndex) {
            throw Error("topLeft and bottomRight must be on the same sheet.");
        }          

        if (a === null || b === null) {
            return [];
        }

        wb = a.workbook;
        sheetIndex = a.sheetIndex;

        var cells = [];
        var colA = a.colIndex;
        var rowA = a.rowIndex;

        var colB = b.colIndex;
        var rowB = b.rowIndex;

        for (var rowNum = rowA; rowNum <= rowB; rowNum++) {
            for (var colNum = colA; colNum <= colB; colNum++) {

                if (mode === 2) {
                    cells.push(fn.ADDRESS(rowNum +1, colNum+1, 0));
                } else if (mode === 3) {
                    cells.push(wb.sheetName( wb.sheetNames[sheetIndex],
                                                   fn.ADDRESS(rowNum +1, colNum+1, 0) ));
                } else if (mode === 4) {
                    cells.push( new cell( wb, sheetIndex, CELLINDEX( rowNum, colNum ) ) );
                } else {
                    cells.push( CELLINDEX( rowNum, colNum ) );
                }
            }
        }
        
        return cells;
    }
  #+END_SRC

** hit

   #+BEGIN_SRC js
     // return true if the address is inside the range
     range.prototype.hit = function(addr) {
         var a,b,target;
         
         target = workbook.cellInfo(addr);
         a = workbook.resolveCell(this.topLeft);
         b = workbook.resolveCell(this.bottomRight);        

         if (a.sheetIndex !== b.sheetIndex) {
             throw Error("topLeft and bottomRight must be on the same sheet.");
         }

         return (target.colIndex >= a.colIndex &&
                 target.colIndex <= b.colIndex &&
                 target.rowIndex >= a.rowIndex &&
                 target.rowIndex <= b.rowIndex);
     }
        
   #+END_SRC

** set

   #+BEGIN_SRC js
     range.prototype.set = function(values) {

         if (!fn.ISARRAY(values)) {
             throw TypeError("Only accepts array of values.");
         }
         var topLeft = workbook.resolveCell(this.topLeft);

         var cells = this.cells();
         for (var i =0; i < cells.length; i++) {
             this.workbook.set(topLeft.sheetIndex, cells[i], values[i]);
         }
     }
   #+END_SRC

** values

   #+BEGIN_SRC js
     range.prototype.values = range.prototype.valueOf = function() {
         var a,b, index;

         a = workbook.resolveCell(this.topLeft);
         b = workbook.resolveCell(this.bottomRight);
         
         if (a.sheetIndex !== b.sheetIndex) {
             throw Error("topLeft and bottomRight must be on the same sheet.");
         }

         if (a === null || b === null) {
             return [];
         }

         this.workbook = a.workbook;
         index = this.sheetIndex = a.sheetIndex;

         var data = [];
         var colA = a.colIndex;
         var rowA = a.rowIndex;

         var colB = b.colIndex;
         var rowB = b.rowIndex;
         
         for (var rowNum = rowA; rowNum <= rowB; rowNum++) {
             // When only 1 column then flatten the output
             if (colA === colB) {
                 data[rowNum-rowA] = this.workbook.getValue(index, rowNum, colA);
             } else {
                 for (var colNum = colA; colNum <= colB; colNum++) {
                     // When only 1 row then flatten the output
                     if (rowA === rowB) {                        
                         data[colNum-colA] = this.workbook.getValue(index, rowNum, colNum); 
                     } else {
                         if (typeof data[rowNum-rowA] === 'undefined') {
                             data[rowNum-rowA] = [];
                         }
                         data[rowNum-rowA][colNum-colA] = this.workbook.getValue(index, rowNum, colNum);
                     }
                 }
             }
         }

         return data;

     }

     range.prototype.toString = function() {
         return workbook.sheetName(this.workbook.sheetNames[this.sheetIndex], this.topLeft.addr) + ":" + this.bottomRight.addr;
     }


  #+END_SRC

* Functions Code 						   :noexport:
:PROPERTIES: 
:noweb-ref: Functions
:END: 

  Functions compatible with most spreadsheet software.
  
  |----------------------+-----------+-------+--------|
  | Category             | Completed | Total | % Done |
  |----------------------+-----------+-------+--------|
  | Date and Time        |        17 |    23 |  74.0% |
  | Engineering          |         2 |    51 |   4.0% |
  | Financial            |         8 |    31 |  26.0% |
  | Information          |        22 |    23 |  96.0% |
  | Logical              |         9 |     9 | 100.0% |
  | Lookup and Reference |        12 |    12 | 100.0% |
  | Math                 |        44 |    69 |  64.0% |
  | Stats                |         4 |    54 |   8.0% |
  | Text                 |        24 |    29 |  83.0% |
  |----------------------+-----------+-------+--------|
  | #                    |       123 |   227 |  55.0% |
  |----------------------+-----------+-------+--------|
  #+TBLFM: @2$4='(concat (number-to-string (fceiling (* 100 (/ (string-to-number (concat $2 ".0")) (string-to-number $3))))) "%")::@3$4='(concat (number-to-string (fceiling (* 100 (/ (string-to-number (concat $2 ".0")) (string-to-number $3))))) "%")::@4$4='(concat (number-to-string (fceiling (* 100 (/ (string-to-number (concat $2 ".0")) (string-to-number $3))))) "%")::@5$4='(concat (number-to-string (fceiling (* 100 (/ (string-to-number (concat $2 ".0")) (string-to-number $3))))) "%")::@6$4='(concat (number-to-string (fceiling (* 100 (/ (string-to-number (concat $2 ".0")) (string-to-number $3))))) "%")::@7$4='(concat (number-to-string (fceiling (* 100 (/ (string-to-number (concat $2 ".0")) (string-to-number $3))))) "%")::@8$4='(concat (number-to-string (fceiling (* 100 (/ (string-to-number (concat $2 ".0")) (string-to-number $3))))) "%")::@9$4='(concat (number-to-string (fceiling (* 100 (/ (string-to-number (concat $2 ".0")) (string-to-number $3))))) "%")::@10$4='(concat (number-to-string (fceiling (* 100 (/ (string-to-number (concat $2 ".0")) (string-to-number $3))))) "%")::@11$2=vsum(@4..10)::@11$3=vsum(@4..10)::@11$4='(concat (number-to-string (fceiling (* 100 (/ (string-to-number (concat $2 ".0")) (string-to-number $3))))) "%")
  
** util
   
   Private functions for function library.
   
*** flatten
    
    The *fn.flatten* function reduces multi-dimensional arrays into a single-dimension.
    
    The function is used by many other functions to simplicify processing of input that may include arbitary dimensions.
    
    #+BEGIN_SRC js
      fn.flatten = function(array){
	  var a = array;
	  if (a.constructor.name === "range") {
	      var a = a.values();
	  }
	  
	  var r = [];
	  
	  function _flatten(a) {    
	      for(var i=0; i<a.length; i++){
		  if (typeof a[i] === "undefined" || a[i] === null) {
		      continue; // empty cell or variable...just keep rolling
		  } else if(a[i].constructor.name === "range") {
		      _flatten(a[i].values());
		  } else if(a[i].constructor == Array) {
		      _flatten(a[i]);
		  } else {
		      r.push(a[i]);
		  }
	      }
	      return r;
	  }

	  return _flatten(a);
      }
    #+END_SRC

*** isAnyError

    #+BEGIN_SRC js
      fn.isAnyError = function() {
	  var n = arguments.length;
	  while (n--) {
	      if (arguments[n] instanceof Error) {
		  return true;
	      }
	  }
	  return false;
      };
    #+END_SRC

*** parseNumber

    #+BEGIN_SRC js
      fn.parseNumber = function(string) {
	  if (string === undefined || string === '') {
	      return error.value;
	  }
	  if (!isNaN(string)) {
	      return parseFloat(string);
	  }
	  return error.value;
      };
    #+END_SRC

*** parseDate

    #+BEGIN_SRC js
      fn.parseDate = function(date) {
          if (typeof date === 'string') {
              date = new Date(date);
              if (!isNaN(date)) {
                  return date;
              }
          } else if (date === date) {
              if (date instanceof Date) {
                  return new Date(date);
              }
              var d = parseInt(date, 10);
              if (d < 0) {
                  return error.num;
              }
              if (d <= 60) {
                  return new Date(d1900.getTime() + (d - 1) * MilliSecondsInDay);
              }
              return new Date(d1900.getTime() + (d - 2) * MilliSecondsInDay);
          }

          return error.value;
      };
    #+END_SRC

*** parseBool

    #+BEGIN_SRC js
      fn.parseBool = function(bool) {
	  if (typeof bool === 'boolean') {
	      return bool;
	  }

	  if (bool instanceof Error) {
	      return bool;
	  }

	  if (typeof bool === 'number') {
	      return bool !== 0;
	  }

	  if (typeof bool === 'string') {
	      var up = bool.toUpperCase();
	      if (up === 'TRUE') {
		  return true;
	      }

	      if (up === 'FALSE') {
		  return false;
	      }
	  }

	  if (bool instanceof Date && !isNaN(bool)) {
	      return true;
	  }

	  return error.value;
      };
    #+END_SRC

*** serial
    
    Dates as sequential serial numbers so they can be used in calculations. By default, 
    January 1, 1900 is serial number 1, and January 1, 2008 is serial number 39448 because 
    it is 39,448 days after January 1, 1900.
    
    #+BEGIN_SRC js
      fn.serial = function(date) {
	  var addOn = (date > -2203891200000)?2:1;
	  return Math.ceil((date - d1900) / MilliSecondsInDay) + addOn;
      }
    #+END_SRC
    
*** serialTime
    
    Dates as sequential serial numbers so they can be used in calculations. By default, 
    January 1, 1900 is serial number 1, and January 1, 2008 is serial number 39448 because 
    it is 39,448 days after January 1, 1900.
    
    #+BEGIN_SRC js
      // DONT THINK THIS WORKS!
      fn.serialTime = function(date) {
          var addOn = (date > -2203891200000)?2:1;
          return ((date - d1900) / MilliSecondsInDay) + addOn;
      }
    #+END_SRC
    
*** validDate
    #+BEGIN_SRC js
      fn.validDate = function(d) {
	  return d && d.getTime && !isNaN(d.getTime());
      }

    #+END_SRC
*** GUID
    #+BEGIN_SRC js
      // credit to http://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript
      // rfc4122 version 4 compliant solution
      fn.GUID = function(){
	  var guid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
	      var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
	      return v.toString(16);
	  });             
	  return guid;
      };
    #+END_SRC
** Date
*** DAY

    #+BEGIN_SRC js
      fn.DAY = function (date) {
	  if (typeof date === "string") {
	      return new Date(date).getDate();
	  } else {
	      return fn.parseDate(date).getDate();
	  }
      }          
    #+END_SRC

*** DATE
    
    #+BEGIN_SRC js
      fn.DATE = function(year, month, day) {
          return fn.serial(new Date(year, month-1, day));
      }
    #+END_SRC

*** DATEDIF

    #+BEGIN_SRC js
      fn.DATEDIF = function(start_date, end_date, unit) {
          var s, e; // start and end serial
          
          if (typeof start_date === "string") {
              start_date = fn.parseDate(start_date);
              s =  fn.serial(start_date);
          } else {
              s = start_date;
              start_date = fn.parseDate(s);
          }

          if (typeof end_date === "string") {
              end_date = fn.parseDate(end_date);
              e =  fn.serial(end_date);
          } else {
              e = end_date;
              end_date = fn.parseDate(e);
          }

          if (end_date === start_date) {
              return 0;
          }

          if (end_date < start_date) {
              return error.num;
          }

          switch (unit) {
          case "Y":
              return end_date.getFullYear() - start_date.getFullYear();
          case "M":
              return (((end_date.getFullYear() - start_date.getFullYear()) * 12)
                      - (start_date.getMonth())
                      + end_date.getMonth());
          case "D":
              return e - s;
          case "MD":
              return "Not supported"
          case "YM":
              return "Not supported"
          case "YD":
              return "Not supported"
          }

          return error.na;
      }

    #+END_SRC

*** DATEVALUE

    #+BEGIN_SRC js
      fn.DATEVALUE = function () {
	  if (!arguments.length) {
	      return new Date();
	  }

	  if (arguments.length === 1) {
	      return fn.serial(new Date(arguments[0]));
	  }

	  var args = arguments;
	  args[1] = args[1] - 1; // Monthes are between 0 and 11.
	  return fn.serial(new (Date.bind.apply(Date, [Date].concat([].splice.call(args, 0))))());
      }          
    #+END_SRC

*** DAYS360

    #+BEGIN_SRC js
      fn.DAYS360 = function(start_date, end_date, method) {
	  method = typeof method === 'undefined' ? false : fn.parseBool(method);
	  start_date = fn.parseDate( fn.DATEVALUE(start_date) );
	  end_date = fn.parseDate( fn.DATEVALUE(end_date) );

	  if (start_date instanceof Error) {
	      return start_date;
	  }
	  if (end_date instanceof Error) {
	      return end_date;
	  }
	  if (method instanceof Error) {
	      return method;
	  }
	  var sm = start_date.getMonth();
	  var em = end_date.getMonth();
	  var sd, ed;
	  if (method) {
	      sd = start_date.getDate() === 31 ? 30 : start_date.getDate();
	      ed = end_date.getDate() === 31 ? 30 : end_date.getDate();
	  } else {
	      var smd = new Date(start_date.getFullYear(), sm + 1, 0).getDate();
	      var emd = new Date(end_date.getFullYear(), em + 1, 0).getDate();
	      sd = start_date.getDate() === smd ? 30 : start_date.getDate();
	      if (end_date.getDate() === emd) {
		  if (sd < 30) {
		      em++;
		      ed = 1;
		  } else {
		      ed = 30;
		  }
	      } else {
		  ed = end_date.getDate();
	      }
	  }
	  return 360 * (end_date.getFullYear() - start_date.getFullYear()) +
	      30 * (em - sm) + (ed - sd);
      };
    #+END_SRC

*** EDATE

    #+BEGIN_SRC js
      fn.EDATE = function(start_date, months) {
	  start_date = fn.parseDate(start_date);
	  if (start_date instanceof Error) {
	      return start_date;
	  }
	  if (isNaN(months)) {
	      return error.value;
	  }
	  months = parseInt(months, 10);
	  start_date.setMonth(start_date.getMonth() + months);
	  return fn.serial(start_date);
      };
    #+END_SRC

*** EOMONTH

    #+BEGIN_SRC js
      fn.EOMONTH = function(start_date, months) {
	  start_date = fn.parseDate(start_date);
	  if (fn.ISERROR(start_date)) {
	      return error.na;
	  }

	  if (months !== months) { // NaN(months)
	      return error.value;
	  }

	  months = parseInt(months, 10);
	  return fn.serial(new Date(start_date.getFullYear(), start_date.getMonth() + months+1, 0));

      };
    #+END_SRC

*** HOUR

    Returns the hour from 0 to 24.

    #+BEGIN_SRC js
      fn.HOUR = function(serial_num) {
          // remove numbers before decimal place and convert fraction to 24 hour scale.
          return fn.FLOOR((serial_num - fn.FLOOR(serial_num)) * 24);
      }
    #+END_SRC

*** ISLEAPYEAR

    #+BEGIN_SRC js
      fn.ISLEAPYEAR = function(date) {
	  date = fn.parseDate(date);
	  var year = date.getFullYear();
	  return (((year % 4 === 0) && (year % 100 !== 0)) ||
		  (year % 400 === 0));
      }
    #+END_SRC

*** ISOWEEKNUM

    #+BEGIN_SRC js
      fn.ISOWEEKNUM = function(date) {
	  date = fn.parseDate(date);
	  if (date instanceof Error) {
	      return date;
	  }

	  date.setHours(0, 0, 0);
	  date.setDate(date.getDate() + 4 - (date.getDay() || 7));
	  var yearStart = new Date(date.getFullYear(), 0, 1);
	  return Math.ceil((((date - yearStart) / MilliSecondsInDay) + 1) / 7);
      };    
    #+END_SRC

*** MINUTE
    
    Extract minute part from serial_num.

    #+BEGIN_SRC js
      fn.MINUTE = function(serial_num) {

          var startval = (serial_num-Math.floor(serial_num)) * SecondsInDay; // get date/time parts
          var hrs = Math.floor(startval / SecondsInHour);
          var startval = startval - hrs * SecondsInHour;

          return Math.floor(startval / 60);
      }
    #+END_SRC

*** MONTH

    #+BEGIN_SRC js
      fn.MONTH = function (timestamp) {
	  var date;
	  if (typeof timestamp === "string") {
	      date = fn.parseDate(fn.DATEVALUE(timestamp));
	  } else {
	      date = fn.parseDate(timestamp);
	  }

	  if (date && !fn.ISERROR(date)) {
	      return date.getMonth() + 1;
	  } else {
	      return date;
	  }

      }    
    #+END_SRC

*** NOW

    #+BEGIN_SRC js
      fn.NOW = function() {
          return fn.serialTime(new Date());
      }         
    #+END_SRC

*** SECOND
    
    Extract minute part from serial_num.

    #+BEGIN_SRC js
      fn.SECOND = function(serial_num) {

          var startval = (serial_num-Math.floor(serial_num)) * SecondsInDay; // get date/time parts
          var hrs = Math.floor(startval / SecondsInHour);
          var startval = startval - hrs * SecondsInHour;
          var mins =  Math.floor(startval / 60);
          return Math.floor(startval - mins * 60);
      }
    #+END_SRC

*** TIME

    #+BEGIN_SRC js
      fn.TIME = function(hour, minute, second) {
        hour = fn.parseNumber(hour);
        minute = fn.parseNumber(minute);
        second = fn.parseNumber(second);
        if (fn.isAnyError(hour, minute, second)) {
          return error.value;
        }
        if (hour < 0 || minute < 0 || second < 0) {
          return error.num;
        }
        return (((SecondsInHour * hour) + (SecondsInMinute * minute) + second) / SecondsInDay);
      };

    #+END_SRC

*** TIMEVALUE

    #+BEGIN_SRC js
      fn.TIMEVALUE = function(time_text) {
          // The JavaScript new Date() does not accept only time.
          // To workaround the issue we put 1/1/1900 at the front.

          var last2Characters = time_text.substr(-2).toUpperCase();
          var date;

          if (time_text.length === 7 && (last2Characters === AM || last2Characters === PM)) {
              time_text = "1/1/1900 " + time_text.substr(0, 5) + " " + last2Characters;
          } else if (time_text.length < 9) {
              time_text = "1/1/1900 " + time_text;
          }

          date = new Date(time_text);
          
          if (date instanceof Error) {
              return date;
          }
          
          return (SecondsInHour * date.getHours() +
                  SecondsInMinute * date.getMinutes() +
                  date.getSeconds()) / SecondsInDay;
      };
    #+END_SRC

*** TODAY

    #+BEGIN_SRC js
      fn.TODAY = function() {
          return fn.FLOOR(fn.NOW())
      }    
    #+END_SRC

*** YEAR

    #+BEGIN_SRC js
      fn.YEAR = function (serial_num) {
          return Math.floor(serial_num / 365) + 1900;
      }
    #+END_SRC

*** YEARFRAC

    #+BEGIN_SRC js
      fn.YEARFRAC = function(start_date, end_date, basis) {
	  start_date = fn.parseDate(start_date);
	  if (start_date instanceof Error) {
	      return start_date;
	  }
	  end_date = fn.parseDate(end_date);
	  if (end_date instanceof Error) {
	      return end_date;
	  }

	  basis = basis || 0;
	  var sd = start_date.getDate();
	  var sm = start_date.getMonth() + 1;
	  var sy = start_date.getFullYear();
	  var ed = end_date.getDate();
	  var em = end_date.getMonth() + 1;
	  var ey = end_date.getFullYear();

	  switch (basis) {
	  case 0:
	      // US (NASD) 30/360
	      if (sd === 31 && ed === 31) {
		  sd = 30;
		  ed = 30;
	      } else if (sd === 31) {
		  sd = 30;
	      } else if (sd === 30 && ed === 31) {
		  ed = 30;
	      }
	      return ((ed + em * 30 + ey * 360) - (sd + sm * 30 + sy * 360)) / 360;
	  case 1:
	      // Actual/actual
	      var feb29Between = function(date1, date2) {
		  var year1 = date1.getFullYear();
		  var mar1year1 = new Date(year1, 2, 1);
		  if (isLeapYear(year1) && date1 < mar1year1 && date2 >= mar1year1) {
		      return true;
		  }
		  var year2 = date2.getFullYear();
		  var mar1year2 = new Date(year2, 2, 1);
		  return (isLeapYear(year2) && date2 >= mar1year2 && date1 < mar1year2);
	      };
	      var ylength = 365;
	      if (sy === ey || ((sy + 1) === ey) && ((sm > em) || ((sm === em) && (sd >= ed)))) {
		  if ((sy === ey && isLeapYear(sy)) ||
		      feb29Between(start_date, end_date) ||
		      (em === 1 && ed === 29)) {
		      ylength = 366;
		  }
		  return daysBetween(start_date, end_date) / ylength;
	      }
	      var years = (ey - sy) + 1;
	      var days = (new Date(ey + 1, 0, 1) - new Date(sy, 0, 1)) / 1000 / 60 / 60 / 24;
	      var average = days / years;
	      return daysBetween(start_date, end_date) / average;
	  case 2:
	      // Actual/360
	      return daysBetween(start_date, end_date) / 360;
	  case 3:
	      // Actual/365
	      return daysBetween(start_date, end_date) / 365;
	  case 4:
	      // European 30/360
	      return ((ed + em * 30 + ey * 360) - (sd + sm * 30 + sy * 360)) / 360;
	  }
      };
    #+END_SRC

** Engineering
*** BIN2DEC

    #+BEGIN_SRC js
      fn.BIN2DEC = function(value) {
	  var valueAsString;

	  if (typeof value === "string") {
	      valueAsString = value;
	  } else if (typeof value !== "undefined") {
	      valueAsString = value.toString();
	  } else {
	      return error.NA;
	  }
	  
	  if (valueAsString.length > 10) return error.NUM;

	  if (valueAsString.length === 10 && valueAsString[0] === '1') {
	      return parseInt(valueAsString.substring(1), 2) - 512;
	  }

	  // Convert binary number to decimal
	  return parseInt(valueAsString, 2);
	  
      };

    #+END_SRC

*** BIN2HEX
*** DEC2BIN
** Logical
*** IF

    #+BEGIN_SRC js :exports none
      fn.IF = function(true_or_false, true_value, false_value) {
	  return ((true_or_false) ? true_value : false_value);
      }
    #+END_SRC
    
*** NOT
    
    #+BEGIN_SRC js :exports none
      fn.NOT = function(logical) {
	  return !logical;
      }
    #+End_src

*** AND

    #+BEGIN_SRC js :exports none
  fn.AND = function() {
      var result = true;
      var list = fn.flatten(arguments);
      for (var i = 0; i < list.length; i++) {
	  result = result && arguments[i];
	  if (!result) return false;
      }
      return true;
  }

    #+END_SRC

*** OR

    #+BEGIN_SRC js :exports none
      fn.OR = function() {
          var result = true;
          var list = fn.flatten(arguments);
          for (var i = 0; i < list.length; i++) {
              result = result && arguments[i];
              if (result) return true;
          }
          return false;
      }

    #+END_SRC

*** IFERROR

    #+BEGIN_SRC js
      fn.IFERROR = function(value, valueIfError) {
          if (fn.ISERROR(value)) {
              return valueIfError;
          }
          return value;
      };
    #+END_SRC

*** IFNA

    #+BEGIN_SRC js
      fn.IFNA = function(value, value_if_na) {
          return value === error.na ? value_if_na : value;
      };
    #+END_SRC

*** XOR

    #+BEGIN_SRC js
      fn.XOR = function() {
          var args = fn.flatten(arguments);
          var result = 0;
          for (var i = 0; i < args.length; i++) {
              if (args[i]) {
                  result++;
              }
          }
          return (result & 1) ? true : false;
      };
    #+END_SRC

*** SWITCH
    
    #+BEGIN_SRC js
      fn.SWITCH = function () {
          var result;
          if (arguments.length > 0)  {
              var targetValue = arguments[0];
              var argc = arguments.length - 1;
              var switchCount = Math.floor(argc / 2);
              var switchSatisfied = false;
              var defaultClause = argc % 2 === 0 ? null : arguments[arguments.length - 1];

              if (switchCount) {
                  for (var index = 0; index < switchCount; index++) {
                      if (targetValue === arguments[index * 2 + 1]) {
                          result = arguments[index * 2 + 2];
                          switchSatisfied = true;
                          break;
                      }
                  }
              }

              if (!switchSatisfied && defaultClause) {
                  result = defaultClause;
              }
          }

          return result;
      };
    #+END_SRC

*** CHOOSE
    
    #+BEGIN_SRC js
      // MORE LISPY Fucking shit in here...haha
      fn.CHOOSE = function(index) {
          if (arguments.length < 2) {
              return error.value;
          }

          var values = [ ];
          for (var i = 1; i < arguments.length; i++) {
              var item = arguments[i];
              if (fn.ISRANGE(item)) {
                  values = values.concat( item.values() );
              } else {
                  values.push(item);
              }
          }

          var retVal = values[index-1];

          if (fn.ISCELL(retVal)){
              return (retVal).valueOf();
          }

          return retVal;
          
      }

    #+END_SRC
    
** Lookup & Reference
*** ADDRESS

    Absolute Relative Modes:
    0. None
    1. Both
    2. Row
    3. Column

    #+BEGIN_SRC js
      fn.ADDRESS = function(row, col, absolute_relative_mode, use_a1_notation, sheet) {
          switch(absolute_relative_mode) {
          case 0:
              return workbook.toColumn(col-1) + (row).toString()
          case 2:
              return workbook.toColumn(col-1) + "$" + (row).toString()
          case 3:
              return "$" + workbook.toColumn(col-1) + (row).toString()
          default:
              return "$" + workbook.toColumn(col-1) + "$" + (row).toString()
          }
      }
    #+END_SRC

*** COLUMN

    #+BEGIN_SRC js
      fn.COLUMN = function(ref) {

          if (fn.ISTEXT(ref)) {
              return workbook.extractCellInfo(ref).col;
          }

          if (fn.ISCELL(ref)) {
              return ref.col;
          }

          return error.na;
      }
    #+END_SRC

*** COLUMNS

    Returns the number of columns in the array or range.

    #+BEGIN_SRC js
      fn.COLUMNS = function(ref) {
          var cols = 0;
          
          if (fn.ISARRAY(ref)) {

              for (var i = 0; i < ref.length; i++) {
                  if (cols === 0) {
                      if (!fn.ISARRAY(ref[i])) {
                          return ref.length;
                      }
                      cols = ref[i].length;
                  } else if (cols === ref[i].length) {
                      continue;
                  } else { // not all columns name size; raise error
                      return error.value;
                  }
              }

              return cols;
          }

          if (fn.ISRANGE(ref)) {
              return ref.bottomRight.colIndex - ref.topLeft.colIndex;
          }

          return error.na;
          
      }
    #+END_SRC

*** LOOKUP
    
    The LOOKUP function supports two forms:
    
    1. Vector Form
       
       LOOKUP(lookup_value, lookup_vector, results_vector)
       
    2. Array Form
       
       LOOKUP(lookup_value, array)
       
    #+BEGIN_SRC js
      fn.LOOKUP = function() {
          var lookup_value, lookup_array, lookup_vector, results_vector;
          if (arguments.length === 2) { // array form
              var wide = false;
              
              lookup_value = arguments[0].valueOf();
              lookup_array = arguments[1];

              if (fn.ISRANGE(lookup_array)) {
                  lookup_array = lookup_array.valueOf();
              }

              for (var i = 0; i < lookup_array.length; i++) {
                  if (typeof lookup_array[i] !== 'undefined' && lookup_value === lookup_array[i].valueOf()) {
                      return lookup_array[i];
                  }
              }

          } else if (arguments.length === 3) { // vector form`
              lookup_value = arguments[0].valueOf();
              lookup_vector = arguments[1];
              results_vector = arguments[2];

              if (fn.ISRANGE(lookup_vector)) {
                  lookup_vector = lookup_vector.valueOf();
              }

              if (fn.ISRANGE(results_vector)) {
                  results_vector = results_vector.valueOf();
              }
              
              for (var i = 0; i < lookup_vector.length; i++) {
                  if (typeof lookup_vector[i] !== 'undefined' && lookup_value === lookup_vector[i].valueOf()) {
                      return results_vector[i];
                  }
              }

          }

          return error.na;

      }
    #+END_SRC
    
*** HLOOKUP
    
    #+BEGIN_SRC js
      fn.HLOOKUP = function(needle, table, index, exactmatch) {
	  if (fn.ISRANGE(table)) {
	      table = table.valueOf();
	  }

	  if (fn.ISCELL(needle)) {
	      needle = needle.valueOf();
	  }

	  if (typeof needle === "undefined" || fn.ISBLANK(needle)) {
	      return null;
	  }

	  index = index || 0;           

	  var row = table[0];               
	  for (var i = 0; i < row.length; i++){               

	      if ((exactmatch && row[i]===needle) ||
		  row[i].toLowerCase().indexOf(needle.toLowerCase()) !== -1) {
		  return (index < (table.length+1) ? table[index-1][i] : table[0][i]);
	      }
	  }             

	  return error.na;
      }
    #+END_SRC

*** INDIRECT

   #+BEGIN_SRC js
     fn.INDIRECT = function(cell_string) {
         return this.cell(cell_string);
     }
   #+END_SRC

*** VLOOKUP

    #+BEGIN_SRC js :exports none		
      fn.VLOOKUP = function(needle, table, index, exactmatch) {             

	  if (fn.ISRANGE(table)) {
	      table = table.valueOf();
	  }

	  if (fn.ISCELL(needle)) {
	      needle = needle.valueOf();
	  }

	  if (fn.ISERROR(needle) || fn.ISBLANK(needle)) {
	      return needle;
	  }

	  index = index || 0;           
	  exactmatch = exactmatch || false;             
	  for (var i = 0; i < table.length; i++){               
	      var row = table[i];               
	      if ((exactmatch && row[0]===needle) ||
		  ((row[0] === needle) ||
		   (typeof row[0] === "string" && row[0].toLowerCase().indexOf(needle.toLowerCase()) != -1) )) {
		  return (index < (row.length+1) ? row[index-1] : row[0]);
	      }
	  }
	  
	  return error.na;

      }                 
    #+END_SRC

*** MATCH

    #+BEGIN_SRC js :exports none		
      fn.MATCH = function(lookup_reference, array_reference, matchType) {
	  var lookupArray, lookupValue;
	  var isRef=false;


	  // Gotta have only 2 arguments folks!
	  if (arguments.length === 2) {
	      matchType = 1;
	  }

	  // Find the lookup value inside a worksheet cell, if needed.
	  if (fn.ISREF(lookup_reference)) {
	      lookupValue = lookup_reference.valueOf();
	  } else {
	      lookupValue = lookup_reference;
	  }
	  

	  // Find the array inside a worksheet range, if needed.
	  if (fn.ISREF(array_reference)) {
	      isRef = true;
	      lookupArray = array_reference.values();
	  } else if (fn.ISARRAY(array_reference)) {
	      lookupArray = array_reference;
	  } else {
	      return error.na;
	  }

	  // Gotta have both lookup value and array
	  if (!lookupValue && !lookupArray) {
	      return error.na;
	  }

	  // Bail on weird match types!
	  if (matchType !== -1 && matchType !== 0 && matchType !== 1) {
	      return error.na;
	  }
	  
	  
	  
	  var index;
	  var indexValue;
	  
	  
	  for (var idx = 0; idx < lookupArray.length; idx++) {
	      if (matchType === 1) {
		  if (lookupArray[idx] === lookupValue) {
		      return idx + 1;
		  } else if (lookupArray[idx] < lookupValue) {
		      if (!indexValue) {
			  index = idx + 1;
			  indexValue = lookupArray[idx];
		      } else if (lookupArray[idx] > indexValue) {
			  index = idx + 1;
			  indexValue = lookupArray[idx];
		      }
		  }
	      } else if (matchType === 0) {
		  if (typeof lookupValue === 'string') {
		      // '?' is mapped to the regex '.'
		      // '*' is mapped to the regex '.*'
		      // '~' is mapped to the regex '\?'
		      if (idx === 0) {
			  lookupValue = "^" + lookupValue.replace(/\?/g, '.').replace(/\*/g, '.*').replace(/~/g, '\\?') + "$";
		      }
		      if (typeof lookupArray[idx] !== "undefined") {
			  if (String(lookupArray[idx]).toLowerCase().match(String(lookupValue).toLowerCase())) {
			      return idx + 1;
			  }
		      }
		  } else {
		      if (typeof lookupArray[idx] !== "undefined" && lookupArray[idx] !== null && lookupArray[idx].valueOf() === lookupValue) {
			  return idx + 1;
		      }
		  }
	      } else if (matchType === -1) {
		  if (lookupArray[idx] === lookupValue) {
		      return idx + 1;
		  } else if (lookupArray[idx] > lookupValue) {
		      if (!indexValue) {
			  index = idx + 1;
			  indexValue = lookupArray[idx];
		      } else if (lookupArray[idx] < indexValue) {
			  index = idx + 1;
			  indexValue = lookupArray[idx];
		      }
		  }
	      }
	  }
	  
	  return index ? index : error.na;
      };

    #+END_SRC

*** OFFSET
    
    #+BEGIN_SRC js
      fn.OFFSET = function(ref, rows, cols, height, width) {
          var topLeft, bottomRight,
              rowsVal = 0, colsVal = 0;

          // handle case when cell object is placed in.
          // reference is the string value (e.g. A1)
          var isCell = fn.ISCELL(ref);
          var reference = isCell ? ref.addr() : ref;

          try {
              
              
              if (reference.indexOf(':') > 0) {
                  topLeft = workbook.cellInfo(reference.split(':')[0]);
              } else {
                  topLeft = workbook.cellInfo(reference);
              }

              // clone object to avoid messing with memorized cells
              topLeft = JSON.parse(JSON.stringify(topLeft));

              if (fn.ISBLANK(rows) || fn.ISBLANK(cols)) {
                  return error.na;
              }
              
              rowsVal = fn.ISCELL(rows) ? rows.valueOf() : rows;
              colsVal = fn.ISCELL(cols) ? cols.valueOf() : cols;

              if (fn.ISERROR(rowsVal) || fn.ISERROR(colsVal)) {
                  return error.na;
              }
              
              topLeft.rowIndex += rowsVal;
              topLeft.colIndex += colsVal;

              bottomRight = JSON.parse(JSON.stringify(topLeft));
              
              if (typeof height !== "undefined" && typeof height === "number") {
                  bottomRight.rowIndex += width;
              }
              
              if (typeof height !== "undefined" && typeof width === "number") {
                  bottomRight.colIndex += height;
              }
              
              var _s = function(point) { return workbook.toColumn(point.colIndex) + (point.rowIndex+1).toString(); }
              topLeft = _s(topLeft);
              bottomRight =  _s(bottomRight);
              if (topLeft === bottomRight) {
                  return ref.workbook.cell(ref.sheetIndex, topLeft);
              } else {
                  return ref.workbook.range(ref.sheetIndex, topLeft, bottomRight);
              }
              
          } catch (e) {
              return workbook.errors.value;
          }
      };
    #+END_SRC

*** INDEX
    
    Find a reference with a row and column offset from an array or reference.
    
    #+BEGIN_SRC js
      fn.INDEX = function(reference, row_num, column_num) {
          var cell, addr, col, row;
          
          if (fn.ISREF(reference)) {
              
              if (fn.ISRANGE(reference)) {
                  cell = workbook.cellInfo(reference.topLeft);
              } else {
                  if (!fn.ISCELL(reference)) { return workbook.errors.na; }
                  cell = workbook.cellInfo(reference.addr());
              }
              
              column_num = column_num || 1;
              col = cell.colIndex + column_num - 1;
              row = cell.rowIndex + row_num ;
              
              addr = workbook.toColumn(col) + (row);
              return reference.sheet.cell(addr);
              
          } else if (fn.ISARRAY(reference)) {
              
              column_num = column_num || 1;
              return reference[row_num-1][column_num-1];
          }
      }
    #+END_SRC

*** ROW

    #+BEGIN_SRC js
      fn.ROW = function(ref) {

          if (fn.ISTEXT(ref)) {
              return workbook.extractCellInfo(ref).row;
          }

          if (fn.ISCELL(ref)) {
              return ref.row;
          }

          return error.na;
          
      }    
    #+END_SRC

*** ROWS

    #+BEGIN_SRC js
      fn.ROWS = function(ref) {
          var cols = 0;
          
          if (fn.ISARRAY(ref)) {

              return ref.length;
          }

          if (fn.ISRANGE(ref)) {
              return ref.bottomRight.rowIndex - ref.topLeft.rowIndex;
          }

          return error.na;
          
      }
    #+END_SRC

** Information
*** CELL

    #+BEGIN_SRC js
      fn.CELL = function(info_type, reference) {

          if (!fn.ISCELL(reference)) {
              return error.NA;
          }
          
          switch (info_type) {

          case "address":
              return reference.addr();
          case "col":
              return reference.colIndex +1;
          case "row":
              return reference.row;
          case "color":
              return error.missing;
          case "contents":
              return error.missing;
          case "format":
              return error.missing;
          case "parentheses":
              return error.missing;
          case "prefix":
              return error.missing;
          case "protect":
              return error.missing;
          case "type":
              return error.missing;
          case "width":
              return error.missing;
          }

      };    
    #+END_SRC

*** DEPENDENTS

    #+BEGIN_SRC js
      fn.DEPENDENTS = function(cell) {
          return cell.sheet.findDependents(cell).map(function(n) {
              return workbook.sheetName(cell.sheet, n.addr());
          });
      };    
    #+END_SRC

*** INFO

    #+BEGIN_SRC js
      fn.INFO = function(text_type) {
      };
    #+END_SRC

*** ISARRAY

    #+BEGIN_SRC js
      fn.ISARRAY = function(arr) {
          return Object.prototype.toString.call( arr ) === '[object Array]' );
      }; 
    #+END_SRC

*** ISBLANK

    #+BEGIN_SRC js
     fn.ISBLANK = function(value) {
	 if (fn.ISCELL(value)) {
	     value = value.valueOf();
	 }
	 
	 return typeof value === 'undefined' || value === null;
     };    
    #+END_SRC

*** ISBINARY

    #+BEGIN_SRC js
     fn.ISBINARY = function (number) {
	 return (/^[01]{1,10}$/).test(number);
     };    
    #+END_SRC

*** ISCELL

    #+BEGIN_SRC js
      fn.ISCELL = function(ref) {
          return (fn.ISOBJECT(ref) && ref.constructor.name === "cell");
      }    
    #+END_SRC

*** ISEMAIL

    #+BEGIN_SRC js
      fn.ISEMAIL = function(email) {
          var re = /^([\w-]+(?:\.[\w-]+)*)@((?:[\w-]+\.)*\w[\w-]{0,66})\.([a-z]{2,6}(?:\.[a-z]{2})?)$/i;
          return re.test(email);
      };
    #+END_SRC

*** ISERR

    #+BEGIN_SRC js
     fn.ISERR = function(value) {
	 if (typeof value === 'undefined' || value === null) { return false; }
	 value = value.valueOf();
	 return ([error.value, error.ref, error.div0, error.num, error.name, error.nil]).indexOf(value) >= 0 ||
	     (typeof value === 'number' && (value !== value || !isFinite(value))); // ensure numbers are not NaN or Infinity
     };    
    #+END_SRC
    
*** ISERROR

    #+BEGIN_SRC js
     fn.ISERROR = function(value) {
	 if (fn.ISCELL(value)) { value = value.valueOf(); }
	 return fn.ISERR(value) || value === error.na;
     };    
    #+END_SRC

*** ISEVEN

    #+BEGIN_SRC js
     fn.ISEVEN = function(value) {
	 if (fn.ISCELL(value)) { value = value.valueOf(); }
	 return (Math.floor(Math.abs(value)) & 1) ? false : true;
     };    
    #+END_SRC

*** ISFORMULA

    #+BEGIN_SRC js
     fn.ISFORMULA = function(ref) {
	 return fn.ISCELL(ref) && ref.workbook.cells[ref.sheetIndex][ref.cellIndex].hasOwnProperty('fid');
     };    
    #+END_SRC

*** ISFUNCTION

    #+BEGIN_SRC js
     fn.ISFUNCTION = function(fun) {
	 return fun && Object.prototype.toString.call(fun) == '[object Function]';
     };    
    #+END_SRC

*** ISLOGICAL

    #+BEGIN_SRC js
     fn.ISLOGICAL = function(value) {
	 return value === true || value === false;
     };    
    #+END_SRC

*** ISNA

    #+BEGIN_SRC js
     fn.ISNA = function(value) {
	 if (fn.ISCELL(value)) { value = value.valueOf(); }
	 return value === error.na;
     };    
    #+END_SRC

*** ISNONTEXT

    #+BEGIN_SRC js
     fn.ISNONTEXT = function(value) {
	 return typeof(value) !== 'string';
     };    
    #+END_SRC
    
*** ISNUMBER

    #+BEGIN_SRC js
     fn.ISNUMBER = function(value) {
	 return typeof(value) === 'number' && !isNaN(value) && isFinite(value);
     };    
    #+END_SRC

*** ISODD

    #+BEGIN_SRC js
     fn.ISODD = function(value) {
	 if (fn.ISCELL(value)) { value = value.valueOf(); }
	 return (Math.floor(Math.abs(value)) & 1) ? true : false;
     };    
    #+END_SRC

*** ISOBJECT

    #+BEGIN_SRC js
     fn.ISOBJECT = function(value) {
	 return (value && typeof value == 'object') || false;
     };   
    #+END_SRC

*** ISRANGE

    #+BEGIN_SRC js
      fn.ISRANGE = function(ref) {
          return (fn.ISOBJECT(ref) && ref.constructor.name === "range");
      };    
    #+END_SRC

*** ISREF

    #+BEGIN_SRC js
     fn.ISREF = function(ref) {
	 return (fn.ISOBJECT(ref) && (ref.constructor.name === "cell" || ref.constructor.name === "range"));
     };    
    #+END_SRC

*** ISTEXT

    #+BEGIN_SRC js
      fn.ISTEXT = function(value) {
          return typeof(value) === 'string';
      };
    #+END_SRC

*** N

    #+BEGIN_SRC js
      fn.N = function(value) {
          if (fn.ISNUMBER(value)) {
              return value;
          }
          if (value instanceof Date) {
              return value.getTime();
          }
          if (value === true) {
              return 1;
          }
          if (value === false) {
              return 0;
          }
          if (fn.ISERROR(value)) {
              return value;
          }
          return 0;
      };    
    #+END_SRC
    
*** NA

    #+BEGIN_SRC js
      fn.NA = function() {
          return error.na;
      };    
    #+END_SRC

*** PRECEDENTS
   #+BEGIN_SRC js
     fn.PRECEDENTS = function(cell) {

	 if (cell.fid) {
	     return cell.workbook.functions[cell.fid].precedents;
	 }

	 return [ ];

     };
   #+END_SRC

*** SHEET

    #+BEGIN_SRC js
      fn.SHEET = function(name) {
          return this.workbook.get(name);
      };    
    #+END_SRC

*** SHEETS

    #+BEGIN_SRC js
     workbook.fn.SHEETS = function() {
	 return Object.keys(this.workbook.sheets).length;
     };    
    #+END_SRC

*** TYPE

    #+BEGIN_SRC js
     workbook.fn.TYPE = function(value) {
	 if (workbook.fn.ISLOGICAL(value)) {
	     return 4;
	 }
	 else if (workbook.fn.ISTEXT(value)) {
	     return 2;
	 }
	 else if (workbook.fn.ISNUMBER(value)) {
	     return 1;
	 }
	 else if (workbook.fn.ISERROR(value)) {
	     return 16;
	 }
	 else if (workbook.fn.ISARRAY(value)) {
	     return 64;
	 }
     };
    #+END_SRC
    
** Misc Functions
*** NUMBERS

    #+BEGIN_SRC js
      fn.NUMBERS = function () {
	  var possibleNumbers = fn.flatten(arguments);

	  var arr = [], n;

	  for (var i = 0; i < possibleNumbers.length; i++) {
	      n = possibleNumbers[i];
	      if (fn.ISNUMBER(n)) {
		  arr.push(n);
	      }
	  }

	  return arr;

      };
    #+END_SRC
    
*** UNIQUE
    
    #+BEGIN_SRC js
      fn.UNIQUE = function () {
	  var result = [];
	  var range = fn.flatten(arguments)
	  for (var i = 0; i < range.length; ++i) {
	      var hasElement = false;
	      var element    = range[i];

	      // Check if we've already seen this element.
	      for (var j = 0; j < result.length; ++j) {
		  hasElement = result[j] === element;
		  if (hasElement) { break; }
	      }

	      // If we did not find it, add it to the result.
	      if (!hasElement) {
		  result.push(element);
	      }
	  }
	  return result;
      };
    #+END_SRC

** Financial
*** ACCRINT
    
    #+BEGIN_SRC js
      fn.ACCRINT = function(issue, first, settlement, rate, par, frequency, basis) {
	  // Return error if either date is invalid
	  var issueDate      = fn.parseDate(fn.DATEVALUE(issue.valueOf()));
	  var firstDate      = fn.parseDate(fn.DATEVALUE(first.valueOf()));
	  var settlementDate = fn.parseDate(fn.DATEVALUE(settlement.valueOf()));

	  // Set default values
	  par   = par.valueOf()   || 0;
	  basis = basis.valueOf() || 0;
	  rate = rate.valueOf();
	  
	  var validDate = fn.validDate;
	  
	  if (!validDate(issueDate) || !validDate(firstDate) || !validDate(settlementDate)) {
	      return error.value;
	  }


	  // Return error if either rate or par are lower than or equal to zero
	  if (rate <= 0 || par <= 0) {
	      return error.num;
	  }

	  // Return error if frequency is neither 1, 2, or 4
	  if ([1, 2, 4].indexOf(frequency.valueOf()) === -1) {
	      return error.num;
	  }

	  // Return error if basis is neither 0, 1, 2, 3, or 4
	  if ([0, 1, 2, 3, 4].indexOf(basis) === -1) {
	      return error.num;
	  }

	  // Return error if settlement is before or equal to issue
	  if (settlementDate <= issueDate) {
	      return error.num;
	  }


	  // Compute accrued interest
	  return par * rate * fn.YEARFRAC(issueDate, settlementDate, basis);
      };
    #+END_SRC
    
*** CUMIPMT
    
    #+BEGIN_SRC js
      fn.CUMIPMT = function(rate, periods, value, start, end, type) {
	  // Credits: algorithm inspired by Apache OpenOffice
	  // Credits: Hannes Stiebitzhofer for the translations of function and variable names
	  var utils = workbook.fn;
	  
	  rate = utils.parseNumber(rate);
	  periods = utils.parseNumber(periods);
	  value = utils.parseNumber(value);
	  if (utils.isAnyError(rate, periods, value)) {
	      return error.value;
	  }

	  // Return error if either rate, periods, or value are lower than or equal to zero
	  if (rate <= 0 || periods <= 0 || value <= 0) {
	      return error.num;
	  }

	  // Return error if start < 1, end < 1, or start > end
	  if (start < 1 || end < 1 || start > end) {
	      return error.num;
	  }

	  // Return error if type is neither 0 nor 1
	  if (type !== 0 && type !== 1) {
	      return error.num;
	  }

	  // Compute cumulative interest
	  var payment = fn.PMT(rate, periods, value, 0, type);
	  var interest = 0;

	  if (start === 1) {
	      if (type === 0) {
		  interest = -value;
		  start++;
	      }
	  }

	  for (var i = start; i <= end; i++) {
	      if (type === 1) {
		  interest += fn.FV(rate, i - 2, payment, value, 1) - payment;
	      } else {
		  interest += fn.FV(rate, i - 1, payment, value, 0);
	      }
	  }
	  interest *= rate;

	  // Return cumulative interest
	  return interest;
      };
    #+END_SRC

*** PMT

    #+BEGIN_SRC js
      fn.PMT = function(rate, periods, present, future, type) {

	  future = fn.N(future) || 0;
	  type = fn.N(type) || 0;

	  var payment;
	  if (rate === 0) {
	      payment = (present + future) / periods;
	  } else {
	      var term = Math.pow(1 + rate, periods);
	      if (type === 1) {
		  payment = (future * rate / (term - 1) + present * rate / (1 - 1 / term)) / (1 + rate);
	      } else {
		  payment = future * rate / (term - 1) + present * rate / (1 - 1 / term);
	      }
	  }
	  return -payment;
      };
    #+END_SRC

*** FV

    #+BEGIN_SRC js
      fn.FV = function(rate, periods, payment, value, type) {

	  if (typeof rate === 'undefined') throw Error("rate is undefined");
	  if (typeof periods === 'undefined') throw Error("rate is undefined");
	  if (typeof payment === 'undefined') throw Error("rate is undefined");

	  value = value || 0;
	  type = type || 0;


	  var fv;
	  if (rate === 0) {
	      fv = value + payment * periods;
	  } else {
	      var term = Math.pow(1 + rate, periods);
	      if (type === 1) {
		  fv = value * term + payment * (1 + rate) * (term - 1) / rate;
	      } else {
		  fv = value * term + payment * (term - 1) / rate;
	      }
	  }
	  return -fv;
      };
    #+END_SRC

*** PV

    #+BEGIN_SRC js
      fn.PV = function(rate, periods, payment, future, type) {
    if (typeof rate === 'undefined') throw Error("rate is undefined");
    if (typeof periods === 'undefined') throw Error("rate is undefined");
    if (typeof payment === 'undefined') throw Error("rate is undefined");
	
    future = future || 0;
    type = type || 0;

    if (rate === 0) {
	return -payment * periods - future;
    } else {
	return (((1 - Math.pow(1 + rate, periods)) / rate) * payment * (1 + rate * type) - future) / Math.pow(1 + rate, periods);
    }
      };
    #+END_SRC

*** NPV

    #+BEGIN_SRC js
      fn.NPV = function(rate) {
          rate = rate * 1;
          var factor = 1,
              sum = 0;

          for(var i = 1; i < arguments.length; i++) {
              var factor = factor * (1 + rate);
              sum += arguments[i] / factor;
          }

          return sum;
      }
    #+END_SRC

*** IPMT

    #+BEGIN_SRC js
      fn.IPMT = function(rate, per, nper, pv, fv, type) {
	  var pmt = fn.PMT(rate, nper, pv, fv, type),
	      fv = fn.FV(rate, per - 1, pmt, pv, type),
	      result = fv * rate;

	  // account for payments at beginning of period versus end.
	  if (type) {
	      result /= (1 + rate);
	  }

	  return result;
      }
    #+END_SRC

*** NPER
    
    #+BEGIN_SRC js
      fn.NPER = function(rate, pmt, pv, fv, type) { 
	  var log,
	      result;
	  rate = parseFloat(rate || 0);
	  pmt = parseFloat(pmt || 0);
	  pv = parseFloat(pv || 0);
	  fv = (fv || 0);
	  type = (type || 0);

	  log = function(prim) {
	      if (isNaN(prim)) {
		  return Math.log(0);
	      }
	      var num = Math.log(prim);
	      return num;
	  }

	  if (rate == 0.0) {
	      result = (-(pv + fv)/pmt);
	  } else if (type > 0.0) {
	      result = (log(-(rate*fv-pmt*(1.0+rate))/(rate*pv+pmt*(1.0+rate)))/(log(1.0+rate)));
	  } else {
	      result = (log(-(rate*fv-pmt)/(rate*pv+pmt))/(log(1.0+rate)));
	  }

	  if (isNaN(result)) {
	      result = 0;
	  }

	  return result;
      }
    #+END_SRC

** Math
*** ABS

    #+BEGIN_SRC js
      fn.ABS = function(v) { return Math.abs(v); }
    #+END_SRC

*** ACOS

    #+BEGIN_SRC js
      fn.ACOS = function(number) {

	  if (!fn.ISNUMBER(number)) {
	      return error.value;
	  }

	  return Math.acos(number);
      };
    #+END_SRC

*** ACOSH
    
    #+BEGIN_SRC js
      fn.ACOSH = function(number) {

	  if (!fn.ISNUMBER(number)) {
	      return error.value;
	  }

	  return Math.log(number + Math.sqrt(number * number - 1));
      };    
    #+END_SRC

*** ACOT

    #+BEGIN_SRC js
      fn.ACOT = function(number) {

	  if (!fn.ISNUMBER(number)) {
	      return error.value;
	  }

	  return Math.atan(1 / number);
      };
	      
    #+END_SRC

*** ACOTH

    #+BEGIN_SRC js
      fn.ACOTH = function(number) {

	  if (!fn.ISNUMBER(number)) {
	      return error.value;
	  }

	  return 0.5 * Math.log((number + 1) / (number - 1));
      };

    #+END_SRC
    
*** ADD

    #+BEGIN_SRC js
      fn.ADD = function(a, b) {

          // force conversion to number
          a = +a;
          b = +b;

          // check for NaN
          if (a !== a || b !== b) {
              return error.value;
          }
          
          return a + b;
      }    
    #+END_SRC
    
*** ASIN

    #+BEGIN_SRC js
      fn.ASIN = function(number) {

	  if (!fn.ISNUMBER(number)) {
	      return error.value;
	  }

	  return Math.asin(number);
      };
    #+END_SRC

*** ASINH

    #+BEGIN_SRC js
      fn.ASINH = function(number) {

	  if (!fn.ISNUMBER(number)) {
	      return error.value;
	  }

	  return Math.log(number + Math.sqrt(number * number + 1));
      };    
    #+END_SRC

*** ATAN

    #+BEGIN_SRC js
      fn.ATAN = function(number) {

          if (!fn.ISNUMBER(number)) {
              return error.value;
          }

          return Math.atan(number);
      };        
    #+END_SRC

*** ATAN2
    
    #+BEGIN_SRC js
      fn.ATAN2 = function(number_x, number_y) {

	  if (!fn.ISNUMBER(number_x)) {
	      return error.value;
	  }

	  if (!fn.ISNUMBER(number_y)) {
	      return error.value;
	  }
	  
	  
	  return Math.atan2(number_x, number_y);
      };
    #+END_SRC

*** ATANH

    #+BEGIN_SRC js
      fn.ATANH = function(number) {

	  if (!fn.ISNUMBER(number)) {
	      return error.value;
	  }

	  return Math.log((1 + number) / (1 - number)) / 2;
      };            
    #+END_SRC

*** BASE

    #+BEGIN_SRC js
      fn.BASE = function(number, radix, min_length) {
	min_length = min_length || 0;

	number = fn.parseNumber(number);
	radix = fn.parseNumber(radix);
	min_length = fn.parseNumber(min_length);
	if (fn.isAnyError(number, radix, min_length)) {
	  return error.value;
	}
	min_length = (min_length === undefined) ? 0 : min_length;
	var result = number.toString(radix);
	return new Array(Math.max(min_length + 1 - result.length, 0)).join('0') + result;

      }
    #+END_SRC

*** CEILING

    #+BEGIN_SRC js
      fn.CEILING = function(number, significance, mode) {
	  var utils = workbook.fn;
	  significance = (significance === undefined) ? 1 : Math.abs(significance);
	  mode = mode || 0;

	  number = utils.parseNumber(number);
	  significance = utils.parseNumber(significance);
	  mode = utils.parseNumber(mode);
	  if (utils.isAnyError(number, significance, mode)) {
	      return error.value;
	  }
	  if (significance === 0) {
	      return 0;
	  }
	  var precision = -Math.floor(Math.log(significance) / Math.log(10));
	  if (number >= 0) {
	      return fn.ROUND(Math.ceil(number / significance) * significance, precision);
	  } else {
	      if (mode === 0) {
		  return -fn.ROUND(Math.floor(Math.abs(number) / significance) * significance, precision);
	      } else {
		  return -fn.ROUND(Math.ceil(Math.abs(number) / significance) * significance, precision);
	      }
	  }
      };

    #+END_SRC

*** CONBIN
    
    #+BEGIN_SRC js
      fn.COMBIN = function(number, number_chosen) {
	  var utils = workbook.fn;
	  number = utils.parseNumber(number);
	  number_chosen = utils.parseNumber(number_chosen);
	  if (utils.isAnyError(number, number_chosen)) {
	      return error.value;
	  }
	  return fn.FACT(number) / (fn.FACT(number_chosen) * fn.FACT(number - number_chosen));
      };

    #+END_SRC

*** COS

    #+BEGIN_SRC js
      fn.COS = function(number) {

	  if (!fn.ISNUMBER(number)) {
	      return error.value;
	  }

	  return Math.cos(number);
      };        
    #+END_SRC

*** COSH

    #+BEGIN_SRC js
      fn.COSH = function(number) {

	  if (!fn.ISNUMBER(number)) {
	      return error.value;
	  }

	  return (Math.exp(number) + Math.exp(-number)) / 2;
      };        
    #+END_SRC

*** COT
    
    #+BEGIN_SRC js
      fn.COT = function(number) {

	  if (!fn.ISNUMBER(number)) {
	      return error.value;
	  }

	  return 1 / Math.tan(number);
      };        
    #+END_SRC

*** COTH

    #+BEGIN_SRC js
      fn.COTH = function(number) {

	  if (!fn.ISNUMBER(number)) {
	      return error.value;
	  }

	  var e2 = Math.exp(2 * number);
	  return (e2 + 1) / (e2 - 1);

      };        
    #+END_SRC

*** CSC

    #+BEGIN_SRC js
      fn.CSC = function(number) {

	  if (!fn.ISNUMBER(number)) {
	      return error.value;
	  }

	  return 1 / Math.sin(number);
      };        
    #+END_SRC

*** CSCH

    #+BEGIN_SRC js
      fn.CSCH = function(number) {

	  if (!fn.ISNUMBER(number)) {
	      return error.value;
	  }

	  return 2 / (Math.exp(number) - Math.exp(-number));
      };        
    #+END_SRC

*** DECIMAL

    #+BEGIN_SRC js
      fn.DECIMAL = function(number, radix) {
	  if (arguments.length < 1) {
	      return error.value;
	  }

	  return parseInt(number, radix);
      };
    #+END_SRC

*** DEGREES

    #+BEGIN_SRC js
      fn.DEGREES = function(number) {
	  if (!fn.ISNUMBER(number)) {
	      return error.value;
	  }

	  return number * 180 / Math.PI;
      };
    #+END_SRC

*** DIVIDE

    #+BEGIN_SRC js
      fn.DIVIDE = function(a, b) {

          // force conversion to number
          a = +a;
          b = +b;

          // check for NaN
          if (a !== a || b !== b) {
              return error.value;
          }
          
          return a / b;
      }    
    #+END_SRC

*** EVEN
    
    #+BEGIN_SRC js
      fn.EVEN = function(number) {
          number = fn.parseNumber(number);
          if (number instanceof Error) {
              return number;
          }
          return fn.CEILING(number, -2, -1);
      };
    #+END_SRC
    
*** EQ

    #+BEGIN_SRC js
      fn.EQ = function(a, b) {
          
          if (fn.ISCELL(a)) {
              a = a.valueOf();
          }

          if (fn.ISCELL(b)) {
              b = b.valueOf();
          }

          // Unlike the host language the string comparisions are 
          if (typeof a === "string" && typeof b === "string") {
              return a.toLowerCase() === b.toLowerCase()
          } else {
              return a === b;
          }

      }    
    #+END_SRC

*** EXP

   #+BEGIN_SRC js
     fn.EXP = function(num) {
         return Math.pow(Math.E, num);
     }
   #+END_SRC

*** FACT
    
    #+BEGIN_SRC js
      var MEMOIZED_FACT = [];
      fn.FACT = function(number) {
          number = fn.parseNumber(number);
          if (number instanceof Error) {
              return number;
          }
          var n = Math.floor(number);
          if (n === 0 || n === 1) {
              return 1;
          } else if (MEMOIZED_FACT[n] > 0) {
              return MEMOIZED_FACT[n];
          } else {
              MEMOIZED_FACT[n] = fn.FACT(n - 1) * n;
              return MEMOIZED_FACT[n];
          }
      };
    #+END_SRC
    
*** FACTDOUBLE

    #+BEGIN_SRC js
      fn.FACTDOUBLE = function(number) {
        number = fn.parseNumber(number);
        if (number instanceof Error) {
          return number;
        }
        var n = Math.floor(number);
        if (n <= 0) {
          return 1;
        } else {
          return n * fn.FACTDOUBLE(n - 2);
        }
      };
    #+END_SRC

*** FLOOR

    #+BEGIN_SRC js
      fn.FLOOR = function (value, significance) {
    significance = significance || 1;

    if (
	(value < 0 && significance > 0 )
      || (value > 0 && significance < 0 )
    ) {
	var result = new Number(0);
	return result;
    }
    if (value >= 0) {
	return Math.floor(value / significance) * significance;
    } else {
	return Math.ceil(value / significance) * significance;
    }
      }
     
    #+END_SRC

*** GCD

    #+BEGIN_SRC js
      // adapted http://rosettacode.org/wiki/Greatest_common_divisor#JavaScript
      fn.GCD = function() {
          var utils = workbook.fn;
          var range = utils.parseNumberArray(utils.flatten(arguments));
          if (range instanceof Error) {
              return range;
          }
          var n = range.length;
          var r0 = range[0];
          var x = r0 < 0 ? -r0 : r0;
          for (var i = 1; i < n; i++) {
              var ri = range[i];
              var y = ri < 0 ? -ri : ri;
              while (x && y) {
                  if (x > y) {
                      x %= y;
                  } else {
                      y %= x;
                  }
              }
              x += y;
          }
          return x;
      };
    #+END_SRC

*** GT

    #+BEGIN_SRC js
      fn.GT = function(a, b) {

          if (fn.ISCELL(a)) {
              a = a.valueOf();
          }

          if (fn.ISCELL(b)) {
              b = b.valueOf();
          }

          return a > b;

      }    
    #+END_SRC

*** GTE

    #+BEGIN_SRC js
      fn.GTE = function(a, b) {

          if (fn.ISCELL(a)) {
              a = a.valueOf();
          }

          if (fn.ISCELL(b)) {
              b = b.valueOf();
          }

          return a >= b;

      }    
    #+END_SRC

*** LCM

    #+BEGIN_SRC js
      fn.LCM = function() {
	  // Credits: Jonas Raoni Soares Silva
	  var utils = workbook.fn;
	  var o = utils.parseNumberArray(utils.flatten(arguments));
	  if (o instanceof Error) {
	      return o;
	  }
	  for (var i, j, n, d, r = 1;
	       (n = o.pop()) !== undefined;) {
	      while (n > 1) {
		  if (n % 2) {
		      for (i = 3, j = Math.floor(Math.sqrt(n)); i <= j && n % i; i += 2) {
			  //empty
		      }
		      d = (i <= j) ? i : n;
		  } else {
		      d = 2;
		  }
		  for (n /= d, r *= d, i = o.length; i;
		       (o[--i] % d) === 0 && (o[i] /= d) === 1 && o.splice(i, 1)) {
		      //empty
		  }
	      }
	  }
	  return r;
      };

    #+END_SRC

*** LN

    #+BEGIN_SRC js
      fn.LN = function(number) {

	  if (!fn.ISNUMBER(number)) {
	      return error.value;
	  }

	  return Math.log(number);
      };        
    #+END_SRC

*** LOG

    #+BEGIN_SRC js
      fn.LOG = function(number, base) {

	  base = base || 10;

	  if (!fn.ISNUMBER(number)) {
	      return error.value;
	  }

	  if (!fn.ISNUMBER(base)) {
	      return error.value;
	  }

	  return Math.log(number) / Math.log(base);

      };        
    #+END_SRC

*** LOG10

    #+BEGIN_SRC js
      fn.LOG10 = function(number) {
	  if (!fn.ISNUMBER(number)) {
	      return error.value;
	  }

	  return Math.log(number) / Math.log(10);
      }
    #+END_SRC

*** LT

    #+BEGIN_SRC js
      fn.LT = function(a, b) {

          if (fn.ISCELL(a)) {
              a = a.valueOf();
          }

          if (fn.ISCELL(b)) {
              b = b.valueOf();
          }

          return a < b;

      }
    #+END_SRC

*** LTE

    #+BEGIN_SRC js
      fn.LTE = function(a, b) {

          if (fn.ISCELL(a)) {
              a = a.valueOf();
          }

          if (fn.ISCELL(b)) {
              b = b.valueOf();
          }

          return a <= b;

      }    
    #+END_SRC

*** INT

    #+BEGIN_SRC js
      fn.INT = function(num) {
          return Math.floor(num);
      }
    #+END_SRC

*** MINUS

    #+BEGIN_SRC js
      fn.MINUS = function(a, b) {

          // force conversion to number
          a = +a;
          b = +b;

          // check for NaN
          if (a !== a || b !== b) {
              return error.value;
          }
          
          return a - b;
      }    
    #+END_SRC

*** MOD

    #+BEGIN_SRC js
      fn.MOD = function(a, b) {
          return a % b;
      }
    #+END_SRC

*** MULTIPLY

    #+BEGIN_SRC js
      fn.MULTIPLY = function(a, b) {

          // force conversion to number
          a = +a;
          b = +b;

          // check for NaN
          if (a !== a || b !== b) {
              return error.value;
          }
          
          return a * b;
      }    
    #+END_SRC

*** NE

    #+BEGIN_SRC js
      fn.NE = function(a, b) {

          if (fn.ISCELL(a)) {
              a = a.valueOf();
          }

          if (fn.ISCELL(b)) {
              b = b.valueOf();
          }

          return a !== b;

      }
    #+END_SRC

*** PI

    #+BEGIN_SRC js
      fn.PI = function() { return Math.PI };
    #+END_SRC

*** POWER

    #+BEGIN_SRC js
      fn.POW = fn.POWER = function(val, nth) {
          return Math.pow(val, nth);
      }
    #+END_SRC

*** PRODUCT

    #+BEGIN_SRC js
      fn.PRODUCT = function() {
          var range = fn.flatten(arguments);
          var result = range[0];
          
          for (var i = 1; i < range.length; i++) {
              result *= range[i];
          }

          return result;
      }
    #+END_SRC

*** QUOTIENT

    #+BEGIN_SRC js
      fn.QUOTIENT = function(a, b) {
          var q = Math.floor( a / b );
          if (q !== q) {
              return error.value;
          }
          return q;
      }
    #+END_SRC

*** RADIANS

    #+BEGIN_SRC js
      fn.RADIANS = function(number) {
        number = fn.parseNumber(number);
        if (number instanceof Error) {
          return number;
        }
        return number * Math.PI / 180;
      };
    #+END_SRC

*** RAND

    #+BEGIN_SRC js
      fn.RAND = function() {
        return Math.random();
      };    
    #+END_SRC

*** RANDBETWEEN

    #+BEGIN_SRC js
      fn.RANDBETWEEN = function(bottom, top) {
        bottom = fn.parseNumber(bottom);
        top = fn.parseNumber(top);
        if (fn.isAnyError(bottom, top)) {
          return error.value;
        }
        // Creative Commons Attribution 3.0 License
        // Copyright (c) 2012 eqcode
        return bottom + Math.ceil((top - bottom + 1) * Math.random()) - 1;
      };
    #+END_SRC

*** ROUND

    #+BEGIN_SRC js :exports none
      fn.ROUND = function(number, precision) {
	  return +number.toFixed(precision);
      }
    #+END_SRC

*** ROUNDUP

    #+BEGIN_SRC js
      fn.ROUNDUP = function(number, precision) {
	  var factors = [1,10,100,1000,10000,100000,1000000,10000000,100000000,1000000000];
	  var factor = factors[precision];
	  if (number > 0) {
	      return Math.ceil(number * factor) / factor;
	  } else {
	      return Math.floor(number * factor) / factor;
	  }
      }

    #+END_SRC

*** SUM

    #+BEGIN_SRC js :exports none
      fn.SUM = function () {
          var numbers = fn.flatten(arguments);
          var result = 0;
          for (var i = 0; i < numbers.length; i++) {
              if (numbers[i] instanceof Array) {
                  for (var j = 0; j < numbers[i].length; j++) {
                      result += (fn.ISNUMBER(numbers[i][j])) ? numbers[i][j] : fn.ISCELL(numbers[i][j]) ? numbers[i][j].valueOf() : 0;
                  }
              } else {
                  result += (fn.ISNUMBER(numbers[i])) ? numbers[i] : fn.ISCELL(numbers[i]) ? numbers[i].valueOf() : 0;
              }
          }

          return result;
      };
    #+END_SRC

*** SUMIF

    #+BEGIN_SRC js
      fn.SUMIF = function (range, criteria) {
          range = fn.flatten(range);
          var result = 0;
          for (var i = 0; i < range.length; i++) {
              result += (eval(range[i] + criteria)) ? range[i] : 0;
          }
          return result;
      }
    #+END_SRC
    
** Stats
*** AVERAGE

    #+BEGIN_SRC js
      fn.AVERAGE = function () {
          var set = fn.flatten.apply(this, arguments);
          return fn.SUM(set) / set.length;
      }
    #+END_SRC

*** COUNT

    #+BEGIN_SRC js
      fn.COUNT = function () {
	  var count = 0,
	      v = arguments,
	      i = v.length - 1;

	  if (i < 0) {
	      return count;
	  }

	  do {
	      if (v[i] !== null) {
		  count++;
	      }
	  } while (i--);

	  return count;
      }
    #+END_SRC

*** COUNTIF

    #+BEGIN_SRC js
      fn.COUNTIF = function(range, criteria) {
          range = fn.flatten(range);
          if (!/[<>=!]/.test(criteria)) {
              criteria = '=="' + criteria + '"';
          }
          var matches = 0;
          for (var i = 0; i < range.length; i++) {
              if (typeof range[i] !== 'string') {

                  if (fn.ISERROR(range[i])) { continue; }
                  if (eval(range[i] + criteria)) {
                      matches++;
                  }
              } else {
                  if (eval('"' + range[i] + '"' + criteria)) {
                      matches++;
                  }
              }
          }
          return matches;
      };

    #+END_SRC

*** MIN

    #+BEGIN_SRC js :exports none
      fn.MIN = function () {

          // flatten the array
          var range = fn.flatten(arguments);
          var min = null;
          var x;

          for (var i = 0; i < range.length; i++) {
              x = range[i];
              if (typeof x !== 'number' || isNaN(x)) { continue; }
              if (min === null) {
                  min = Number(x); 
              }else if (x < min) {
                  min = Number(x);
              }
          }

          return min;
      };
    #+END_SRC

*** MAX
    #+BEGIN_SRC js :exports none
      fn.MAX = function () {

          // flatten the array
          var range = fn.flatten(arguments);
          var max = null;
          var x;

          for (var i = 0; i < range.length; i++) {
              x = range[i];
              if (typeof x !== 'number' || isNaN(x)) { continue; }
              if (max === null) {
                  max = Number(x); 
              }else if (x > max) {
                  max = Number(x);
              }
          }

          return max;
      };
    #+END_SRC
    
*** SLOPE
    
    #+BEGIN_SRC js
      fn.SLOPE = function(data_y, data_x) {
      /*
	  data_y = utils.parseNumberArray(utils.flatten(data_y));
	  data_x = utils.parseNumberArray(utils.flatten(data_x));

	  if (utils.anyIsError(data_y, data_x)) {
	      return error.value;
	  }
	  var xmean = jStat.mean(data_x);
	  var ymean = jStat.mean(data_y);
	  
	  var n = data_x.length;

	  var num = 0;
	  var den = 0;

	  for (var i = 0; i < n; i++) {
	      num += (data_x[i] - xmean) * (data_y[i] - ymean);
	      den += Math.pow(data_x[i] - xmean, 2);
	  }

	  return num / den;
      ,*/
      };
    #+END_SRC
    
** Text
*** CHAR
    
    #+BEGIN_SRC js
      fn.CHAR = function(number) {
	  number = fn.parseNumber(number);
	  if (number instanceof Error) {
	      return number;
	  }
	  return String.fromCharCode(number);
      };
    #+END_SRC
    
*** CLEAN

    Removes the first 32 non-printing characters from the ASCII character set.

    #+BEGIN_SRC js
      fn.CLEAN = function(text) {
          var out = "";

          for (var i = 0; i < text.length; i++) {
              if (text.charCodeAt(i) > 31) {
                  out += text[i];
              }
          }

          return out;
      }
    #+END_SRC

*** CODE

    #+BEGIN_SRC js
      fn.CODE = function(text) {
	  text = text || '';
	  return text.charCodeAt(0);
      };
    #+END_SRC

*** CONCATENATE

    #+BEGIN_SRC js
      fn.CONCAT = fn.CONCATENATE = function() {
          var args = fn.flatten(arguments);

          for (var i = 0; i < args.length; i++) {
              if (args[i] === true) { args[i] = 'TRUE'; }
              else if (args[i] === false) { args[i] = 'FALSE'; }
              else { args[i] = args[i] ? args[i].valueOf() : '' }
          }

          return args.join('');
      };
    #+END_SRC

*** DOLLAR

    #+BEGIN_SRC js
      fn.DOLLAR = function(num) {
          return fn.TEXT(num, '$#,##0.00_);($#,##0.00)');
      }
    #+END_SRC

*** EXACT

    #+BEGIN_SRC js
      fn.EXACT = function(a, b) {
          
          if (fn.ISCELL(a)) {
              a = a.valueOf();
          }

          if (fn.ISCELL(b)) {
              b = b.valueOf();
          }

          if (typeof a !== "string" || typeof b !== "string") {
              return error.na;
          }

          return a === b;
      }
    #+END_SRC

*** FIND

    #+BEGIN_SRC js
      fn.FIND = function (find_text, within_text, position) {
	  if (!within_text) { return null; }
	  position = (typeof position === 'undefined') ? 1 : position;
	  position = within_text.indexOf(find_text, position - 1) + 1;
	  return position === 0 ? workbook.errors.value : position;
      }
    #+END_SRC

*** FIXED
    
    #+BEGIN_SRC js
      fn.FIXED = function(num, decimals, commas) {
          if (commas) { return num.toFixed(decimals).replace(/\B(?=(\d{3})+(?!\d))/g, ","); }
          return num.toFixed(decimals);
      }
    #+END_SRC

*** LEFT

    #+BEGIN_SRC js
      fn.LEFT = function(text, number) {
	  number = (number === undefined) ? 1 : number;
	  number = fn.parseNumber(number);
	  if (number instanceof Error || typeof text !== 'string') {
	      return error.value;
	  }
	  return text ? text.substring(0, number) : null;
      };
    #+END_SRC

*** LEN

    #+BEGIN_SRC js
      LEN = function(text) {
    if (arguments.length === 0) {
	return error.error;
    }

    if (typeof text === 'string') {
	return text ? text.length : 0;
    }

    if (text.length) {
	return text.length;
    }

    return error.value;
      };
    #+END_SRC

*** LOWER

    #+BEGIN_SRC js
      fn.LOWER = function(text) {
	  if (typeof text === 'undefined' || text === null) return "";
	  return text.toLowerCase();
      }     
    #+END_SRC

*** JOIN

    #+BEGIN_SRC js
      fn.JOIN = function (array, separator) {
	  return array.join(separator);
      };
    #+END_SRC

*** MID

    #+BEGIN_SRC js
      fn.MID = function(text, start, number) {
          start = fn.parseNumber(start);
          number = fn.parseNumber(number);
          if (fn.isAnyError(start, number) || typeof text !== 'string') {
              return number;
          }
          return text.substring(start - 1, number+1);
      };
    #+END_SRC

*** PROPER

    #+BEGIN_SRC js
      fn.PROPER = function(text) {
          if (text === undefined || text.length === 0) {
              return error.value;
          }
          if (text === true) {
              text = 'TRUE';
          }
          if (text === false) {
              text = 'FALSE';
          }
          if (isNaN(text) && typeof text === 'number') {
              return error.value;
          }
          if (typeof text === 'number') {
              text = '' + text;
          }

          return text.replace(/\w\S*/g, function(txt) {
              return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
          });
      };
    #+END_SRC

*** REPLACE

    #+BEGIN_SRC js
      fn.REPLACE = function(text, position, length, new_text) {
	  position = fn.parseNumber(position);
	  length = fn.parseNumber(length);
	  if (fn.isAnyError(position, length) ||
	      typeof text !== 'string' ||
	      typeof new_text !== 'string') {
	      return error.value;
	  }
	  return text.substr(0, position - 1) + new_text + text.substr(position - 1 + length);
      };
    #+END_SRC

*** REPT

    #+BEGIN_SRC js
      fn.REPT = function(t, n) {
          var r = "";
          for (var i = 0; i < n; i++) {
              r += t;
          }
          return r;
      }
    #+END_SRC

*** RIGHT

    #+BEGIN_SRC js
      fn.RIGHT = function(text, number) {
	  number = (number === undefined) ? 1 : number;
	  number = fn.parseNumber(number);
	  if (number instanceof Error) {
	      return number;
	  }
	  return text ? text.substring(text.length - number) : null;
      };
    #+END_SRC

*** SEARCH
    
    #+BEGIN_SRC js
      fn.SEARCH = function (find_text, within_text, position) {
	  if (!within_text) { return null; }
	  position = (typeof position === 'undefined') ? 1 : position;

	  // The SEARCH function translated the find_text into a regex.
	  var find_exp = find_text
	      .replace(/([^~])\?/g, '$1.')   // convert ? into .
	      .replace(/([^~])\*/g, '$1.*')  // convert * into .*
	      .replace(/([~])\?/g, '\\?')    // convert ~? into \?
	      .replace(/([~])\*/g, '\\*');   // convert ~* into \*

	  position = new RegExp(find_exp, "i").exec(within_text);

	  if (position) { return position.index + 1 }
	  return workbook.errors.value;
      }
    #+END_SRC

*** SPLIT

    #+BEGIN_SRC js
      fn.SPLIT = function (text, separator) {
          return text.split(separator);
      };
    #+END_SRC

*** SUBSTITUTE

    #+BEGIN_SRC js
      fn.SUBSTITUTE = function(text, old_text, new_text, occurrence) {
	  if (!text || !old_text || !new_text) {
	      return text;
	  } else if (occurrence === undefined) {
	      return text.replace(new RegExp(old_text, 'g'), new_text);
	  } else {
	      var index = 0;
	      var i = 0;
	      while (text.indexOf(old_text, index) > 0) {
		  index = text.indexOf(old_text, index + 1);
		  i++;
		  if (i === occurrence) {
		      return text.substring(0, index) + new_text + text.substring(index + old_text.length);
		  }
	      }
	  }
      };
    #+END_SRC

*** T
    
    #+BEGIN_SRC js
      fn.T = function(value) {
	  return (typeof value === "string") ? value : '';
      };
    #+END_SRC

*** TEXT

    #+BEGIN_SRC js
      fn.TEXT = function(value, format) {
	  return workbook.FormatNumber.formatNumberWithFormat(value, format);
      };
    #+END_SRC

*** TRIM

    #+BEGIN_SRC js
      fn.TRIM = function(text) {
	  if (typeof text !== 'string') {
	      return error.value;
	  }
	  return text.replace(/ +/g, ' ').trim();
      };
    #+END_SRC

*** UPPER

    #+BEGIN_SRC js
      fn.UPPER = function(text) {
	  if (typeof text === 'undefined' || text === null) return "";
	  return text.toUpperCase();
      }     
    #+END_SRC

*** VALUE

    This is hopelessly inadequate.

    #+BEGIN_SRC js
      fn.VALUE = function(t) {
          return Number.parseFloat(t);
      }
    #+End_src
    
* Formula Parser Code 						   :noexport:
  
  The *Formula Parser* is a JavaScript parser for spreadsheet formulas; created using the [[https://zaach.github.io/jison/][jison]] parser generator.
  
  The formulas are converted to JavaScript and compiled to functions with eval.
  
** Grammar
   
   The grammar provides a formal definition for both the lexical and language semantics.
   
   The lexical grammar defines the formal semanics for identifying tokens.
   
   Running this source code block will generate parser named *parser.js* by running the jison command line.
   
   
   #+BEGIN_SRC jison :file parser.js :cmdline "-m js" :exports code

     /* description: Parses end executes spreadsheet formula expressions. */

     /* lexical grammar */
     %lex

     alpha                       [a-zA-Z]
     digit                       [0-9]
     esc                         "\""
     int                         "-"?(?:[0-9]|[1-9][0-9]+)
     exp                         (?:[eE][-+]?[0-9]+)
     frac                        (?:\.[0-9]+)

     %%

     \s+                   /* skip whitespace */
     [0-9]+("."[0-9]+)?\b  return 'NUMBER'
     "TRUE"                return 'TRUE'
     "FALSE"               return 'FALSE'
     "*"                   return '*'
     "/"                   return '/'
     "-"                   return '-'
     "+"                   return '+'
     "&"                   return '&'
     "^"                   return '^'
     "("                   return '('
     ")"                   return ')'
     ">="                  return ">="
     "<="                  return "<="
     "<>"                  return "<>"
     "="                   return "="
     ">"                   return ">"
     "<"                   return "<"
     "{"                   return "{"
     "}"                   return "}"
     "!"                   return "!"
     ","                   return ","
     ":"                   return ":"
     ";"                   return ";"
     "%"                   return "%"
     [A-Za-z](?=[(])                    {return 'FUNC';}
     [A-Za-z][A-Za-z0-9\.]+(?=[(])                    {return 'FUNC';}
     \$\'(?:\'\'|[^'])*\'\!    yytext = yytext.substr(2,yyleng-3).replace(/\"\"/g, "\""); return "SHEET";
     \'(?:\'\'|[^'])*\'\!    yytext = yytext.substr(1,yyleng-3).replace(/\"\"/g, "\""); return "SHEET";
     [a-zA-Z]([a-zA-Z0-9.$]+)?\!  yytext = yytext.slice(0, -1); return "SHEET"
     \$([a-zA-Z])([a-zA-Z0-9.$]+)?\!  yytext = yytext.slice(1, -1); return "SHEET"
     \$?([a-zA-Z]+)\$?([0-9]+)                              return "CELL";
     \"(?:\"\"|[^"])*\"    yytext = yytext.substr(1,yyleng-2).replace(/\"\"/g, "\""); return "STRING";
     [a-zA-Z]([a-zA-Z0-9.$^\(]+)?  return 'IDENT'
     <<EOF>>               return 'EOF'
     .                     return 'INVALID'

     /lex

     /* operator associations and precedence */
     %left '=' '>=' '<=' '>' '<' '<>'
     %left '&'
     %left '+' '-'
     %left '*' '/'
     %left '^'
     %left ':'
     %left UMINUS

     %right '%'


     %start expressions

     %% /* language grammar */

     expressions
     : e EOF
         { return $1; }
     | '=' e EOF
         { return $2; }
     ;

       e          
     : e '+' e
         {$$ = { type: "operator", subtype: 'infix-add', operands:[$1, $3]}; }
     | e '-' e
         {$$ = { type: "operator", subtype: 'infix-subtract', operands:[$1, $3]}; }
     | e '*' e
         {$$ = { type: "operator", subtype: 'infix-multiply', operands:[$1, $3]}; }
     | e '/' e
         {$$ = { type: "operator", subtype: 'infix-divide', operands:[$1, $3] }; }
     | e '^' e
         {$$ = { type: "operator", subtype: 'infix-power', operands:[$1, $3] }; }
     | e '<>' e
         {$$ = { type: "operator", subtype: 'infix-ne', operands:[$1, $3] }; }
     | e '=' e
         {$$ = { type: "operator", subtype: 'infix-eq', operands:[$1, $3] }; }
     | e '>' e
         {$$ = { type: "operator", subtype: 'infix-gt', operands:[$1, $3] }; }
     | e '<' e
         {$$ = { type: "operator", subtype: 'infix-lt', operands:[$1, $3] }; }
     | e '>=' e
         {$$ = { type: "operator", subtype: 'infix-gte', operands:[$1, $3] }; }
     | e '<=' e
         {$$ = { type: "operator", subtype: 'infix-lte', operands:[$1, $3] }; }
           | '+' e
         {$$ = { type: "operator", subtype: 'prefix-plus', operands:[$2] }; }
     | e '&' e
         {$$ = { type: "operator", subtype: 'infix-concat', operands:[$1, $3] }; }
     | func '&' e
         {$$ = { type: "operator", subtype: 'infix-concat', operands:[$1, $3] }; } 
     | '-' e %prec UMINUS
         {$$ = { type: "operator", subtype: 'prefix-minus', operands:[$2] }; }
     | '(' e ')'
         {$$ = { type: 'group', exp:$2 }; }
     | e ':' e
         {$$ = { type: 'range', subtype: 'local', topLeft:$1, bottomRight:$3 }; }
     | CELL
         {$$ = { type: 'cell', subtype: 'local', addr:$1 }; }
     | SHEET CELL
         { $$ = { type: 'cell', subtype: 'remote', worksheet: $1, addr:$2 }; }
     | IDENT
         { $$ = { type: 'value', subtype: 'variable', value:$1 }; }
     | SHEET IDENT
         { $$ = { type: 'cell', subtype: 'remote-named', worksheet: $1, addr:$2 }; }
     | func
         { $$ = $1; }
     | array_literal
         { $$ = $1; }         
     | TRUE
         {$$ = { type: 'value', subtype: 'boolean', value: true }; }
     | FALSE
         {$$ = { type: 'value', subtype: 'boolean', value: false }; }
     | STRING
         {$$ = { type: 'value', subtype: 'string', value:String(yytext)}; }
     | NUMBER '%'
         {$$ = { type: 'value', subtype: 'number', value:$1/100 }; }
           | NUMBER
         {$$ = { type: 'value', subtype: 'number', value:Number(yytext) }; }
     ;


     range
        : e ':' e
        ;

       param_list
     :  e
         { $$ = [$1]; }
     | param_list ',' e
         { $$ = $1.concat([$3]); } 
     | param_list ';' param_list
         { $$ = ($3[0].subtype !== 'array') ? [{ type: 'value', subtype: 'array', items:$1 }, { type: 'value', subtype: 'array', items:$3 }] : [{ type: 'value', subtype: 'array', items:$1 }].concat($3); } 
     ;

       func
           : FUNC '(' param_list ')'
         { $$ = { type: 'function', name: $1, args:$3 }; }
     | FUNC '(' ')'
         { $$ = { type: 'function', name: $1, args:[] }; }
     ;

       array_literal
     : '{' param_list '}'
         { $$ = { type: 'value', subtype: 'array', items:$2 }; }
     ;

   #+END_SRC
   
   #+RESULTS:
   [[file:parser.js]]

** JavaScript
   
   The jison generated parser in JavaScript.
   
   #+NAME: FormulaParser
   #+BEGIN_SRC js
     /* parser generated by jison 0.4.15 */
     /*
       Returns a Parser object of the following structure:

       Parser: {
         yy: {}
       }

       Parser.prototype: {
         yy: {},
         trace: function(),
         symbols_: {associative list: name ==> number},
         terminals_: {associative list: number ==> name},
         productions_: [...],
         performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
         table: [...],
         defaultActions: {...},
         parseError: function(str, hash),
         parse: function(input),

         lexer: {
             EOF: 1,
             parseError: function(str, hash),
             setInput: function(input),
             input: function(),
             unput: function(str),
             more: function(),
             less: function(n),
             pastInput: function(),
             upcomingInput: function(),
             showPosition: function(),
             test_match: function(regex_match_array, rule_index),
             next: function(),
             lex: function(),
             begin: function(condition),
             popState: function(),
             _currentRules: function(),
             topState: function(),
             pushState: function(condition),

             options: {
                 ranges: boolean           (optional: true ==> token location info will include a .range[] member)
                 flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
                 backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
             },

             performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
             rules: [...],
             conditions: {associative list: name ==> set},
         }
       }


       token location info (@$, _$, etc.): {
         first_line: n,
         last_line: n,
         first_column: n,
         last_column: n,
         range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
       }


       the parseError function receives a 'hash' object with these members for lexer and parser errors: {
         text:        (matched text)
         token:       (the produced terminal token, if any)
         line:        (yylineno)
       }
       while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
         loc:         (yylloc)
         expected:    (string describing the set of expected tokens)
         recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
       }
     ,*/
     var parser = (function(){
     var o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,4],$V1=[1,6],$V2=[1,7],$V3=[1,8],$V4=[1,9],$V5=[1,10],$V6=[1,12],$V7=[1,13],$V8=[1,14],$V9=[1,15],$Va=[1,16],$Vb=[1,17],$Vc=[1,25],$Vd=[1,19],$Ve=[1,20],$Vf=[1,21],$Vg=[1,22],$Vh=[1,23],$Vi=[1,24],$Vj=[1,26],$Vk=[1,27],$Vl=[1,28],$Vm=[1,29],$Vn=[1,30],$Vo=[1,31],$Vp=[5,6,7,8,9,10,11,12,13,14,15,16,17,20,21,33,34,37],$Vq=[5,6,7,8,12,13,14,15,16,17,20,33,34,37],$Vr=[1,62],$Vs=[1,63],$Vt=[20,33,34,37],$Vu=[5,6,7,8,9,10,12,13,14,15,16,17,20,33,34,37],$Vv=[5,6,12,13,14,15,16,20,33,34,37],$Vw=[5,6,12,13,14,15,16,17,20,33,34,37];
     var parser = {trace: function trace() { },
     yy: {},
     symbols_: {"error":2,"expressions":3,"e":4,"EOF":5,"=":6,"+":7,"-":8,"*":9,"/":10,"^":11,"<>":12,">":13,"<":14,">=":15,"<=":16,"&":17,"func":18,"(":19,")":20,":":21,"CELL":22,"SHEET":23,"IDENT":24,"array_literal":25,"TRUE":26,"FALSE":27,"STRING":28,"NUMBER":29,"%":30,"range":31,"param_list":32,",":33,";":34,"FUNC":35,"{":36,"}":37,"$accept":0,"$end":1},
     terminals_: {2:"error",5:"EOF",6:"=",7:"+",8:"-",9:"*",10:"/",11:"^",12:"<>",13:">",14:"<",15:">=",16:"<=",17:"&",19:"(",20:")",21:":",22:"CELL",23:"SHEET",24:"IDENT",26:"TRUE",27:"FALSE",28:"STRING",29:"NUMBER",30:"%",33:",",34:";",35:"FUNC",36:"{",37:"}"},
     productions_: [0,[3,2],[3,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,2],[4,3],[4,3],[4,2],[4,3],[4,3],[4,1],[4,2],[4,1],[4,2],[4,1],[4,1],[4,1],[4,1],[4,1],[4,2],[4,1],[31,3],[32,1],[32,3],[32,3],[18,4],[18,3],[25,3]],
     performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
     /* this == yyval */

     var $0 = $$.length - 1;
     switch (yystate) {
     case 1: case 2:
      return $$[$0-1]; 
     break;
     case 3:
     this.$ = { type: "operator", subtype: 'infix-add', operands:[$$[$0-2], $$[$0]]}; 
     break;
     case 4:
     this.$ = { type: "operator", subtype: 'infix-subtract', operands:[$$[$0-2], $$[$0]]}; 
     break;
     case 5:
     this.$ = { type: "operator", subtype: 'infix-multiply', operands:[$$[$0-2], $$[$0]]}; 
     break;
     case 6:
     this.$ = { type: "operator", subtype: 'infix-divide', operands:[$$[$0-2], $$[$0]] }; 
     break;
     case 7:
     this.$ = { type: "operator", subtype: 'infix-power', operands:[$$[$0-2], $$[$0]] }; 
     break;
     case 8:
     this.$ = { type: "operator", subtype: 'infix-ne', operands:[$$[$0-2], $$[$0]] }; 
     break;
     case 9:
     this.$ = { type: "operator", subtype: 'infix-eq', operands:[$$[$0-2], $$[$0]] }; 
     break;
     case 10:
     this.$ = { type: "operator", subtype: 'infix-gt', operands:[$$[$0-2], $$[$0]] }; 
     break;
     case 11:
     this.$ = { type: "operator", subtype: 'infix-lt', operands:[$$[$0-2], $$[$0]] }; 
     break;
     case 12:
     this.$ = { type: "operator", subtype: 'infix-gte', operands:[$$[$0-2], $$[$0]] }; 
     break;
     case 13:
     this.$ = { type: "operator", subtype: 'infix-lte', operands:[$$[$0-2], $$[$0]] }; 
     break;
     case 14:
     this.$ = { type: "operator", subtype: 'prefix-plus', operands:[$$[$0]] }; 
     break;
     case 15: case 16:
     this.$ = { type: "operator", subtype: 'infix-concat', operands:[$$[$0-2], $$[$0]] }; 
     break;
     case 17:
     this.$ = { type: "operator", subtype: 'prefix-minus', operands:[$$[$0]] }; 
     break;
     case 18:
     this.$ = { type: 'group', exp:$$[$0-1] }; 
     break;
     case 19:
     this.$ = { type: 'range', subtype: 'local', topLeft:$$[$0-2], bottomRight:$$[$0] }; 
     break;
     case 20:
     this.$ = { type: 'cell', subtype: 'local', addr:$$[$0] }; 
     break;
     case 21:
      this.$ = { type: 'cell', subtype: 'remote', worksheet: $$[$0-1], addr:$$[$0] }; 
     break;
     case 22:
      this.$ = { type: 'value', subtype: 'variable', value:$$[$0] }; 
     break;
     case 23:
      this.$ = { type: 'cell', subtype: 'remote-named', worksheet: $$[$0-1], addr:$$[$0] }; 
     break;
     case 24: case 25:
      this.$ = $$[$0]; 
     break;
     case 26:
     this.$ = { type: 'value', subtype: 'boolean', value: true }; 
     break;
     case 27:
     this.$ = { type: 'value', subtype: 'boolean', value: false }; 
     break;
     case 28:
     this.$ = { type: 'value', subtype: 'string', value:String(yytext)}; 
     break;
     case 29:
     this.$ = { type: 'value', subtype: 'number', value:$$[$0-1]/100 }; 
     break;
     case 30:
     this.$ = { type: 'value', subtype: 'number', value:Number(yytext) }; 
     break;
     case 32:
      this.$ = [$$[$0]]; 
     break;
     case 33:
      this.$ = $$[$0-2].concat([$$[$0]]); 
     break;
     case 34:
      this.$ = ($$[$0][0].subtype !== 'array') ? [{ type: 'value', subtype: 'array', items:$$[$0-2] }, { type: 'value', subtype: 'array', items:$$[$0] }] : [{ type: 'value', subtype: 'array', items:$$[$0-2] }].concat($$[$0]); 
     break;
     case 35:
      this.$ = { type: 'function', name: $$[$0-3], args:$$[$0-1] }; 
     break;
     case 36:
      this.$ = { type: 'function', name: $$[$0-2], args:[] }; 
     break;
     case 37:
      this.$ = { type: 'value', subtype: 'array', items:$$[$0-1] }; 
     break;
     }
     },
     table: [{3:1,4:2,6:[1,3],7:$V0,8:$V1,18:5,19:$V2,22:$V3,23:$V4,24:$V5,25:11,26:$V6,27:$V7,28:$V8,29:$V9,35:$Va,36:$Vb},{1:[3]},{5:[1,18],6:$Vc,7:$Vd,8:$Ve,9:$Vf,10:$Vg,11:$Vh,12:$Vi,13:$Vj,14:$Vk,15:$Vl,16:$Vm,17:$Vn,21:$Vo},{4:32,7:$V0,8:$V1,18:5,19:$V2,22:$V3,23:$V4,24:$V5,25:11,26:$V6,27:$V7,28:$V8,29:$V9,35:$Va,36:$Vb},{4:33,7:$V0,8:$V1,18:5,19:$V2,22:$V3,23:$V4,24:$V5,25:11,26:$V6,27:$V7,28:$V8,29:$V9,35:$Va,36:$Vb},o([5,6,7,8,9,10,11,12,13,14,15,16,20,21,33,34,37],[2,24],{17:[1,34]}),{4:35,7:$V0,8:$V1,18:5,19:$V2,22:$V3,23:$V4,24:$V5,25:11,26:$V6,27:$V7,28:$V8,29:$V9,35:$Va,36:$Vb},{4:36,7:$V0,8:$V1,18:5,19:$V2,22:$V3,23:$V4,24:$V5,25:11,26:$V6,27:$V7,28:$V8,29:$V9,35:$Va,36:$Vb},o($Vp,[2,20]),{22:[1,37],24:[1,38]},o($Vp,[2,22]),o($Vp,[2,25]),o($Vp,[2,26]),o($Vp,[2,27]),o($Vp,[2,28]),o($Vp,[2,30],{30:[1,39]}),{19:[1,40]},{4:42,7:$V0,8:$V1,18:5,19:$V2,22:$V3,23:$V4,24:$V5,25:11,26:$V6,27:$V7,28:$V8,29:$V9,32:41,35:$Va,36:$Vb},{1:[2,1]},{4:43,7:$V0,8:$V1,18:5,19:$V2,22:$V3,23:$V4,24:$V5,25:11,26:$V6,27:$V7,28:$V8,29:$V9,35:$Va,36:$Vb},{4:44,7:$V0,8:$V1,18:5,19:$V2,22:$V3,23:$V4,24:$V5,25:11,26:$V6,27:$V7,28:$V8,29:$V9,35:$Va,36:$Vb},{4:45,7:$V0,8:$V1,18:5,19:$V2,22:$V3,23:$V4,24:$V5,25:11,26:$V6,27:$V7,28:$V8,29:$V9,35:$Va,36:$Vb},{4:46,7:$V0,8:$V1,18:5,19:$V2,22:$V3,23:$V4,24:$V5,25:11,26:$V6,27:$V7,28:$V8,29:$V9,35:$Va,36:$Vb},{4:47,7:$V0,8:$V1,18:5,19:$V2,22:$V3,23:$V4,24:$V5,25:11,26:$V6,27:$V7,28:$V8,29:$V9,35:$Va,36:$Vb},{4:48,7:$V0,8:$V1,18:5,19:$V2,22:$V3,23:$V4,24:$V5,25:11,26:$V6,27:$V7,28:$V8,29:$V9,35:$Va,36:$Vb},{4:49,7:$V0,8:$V1,18:5,19:$V2,22:$V3,23:$V4,24:$V5,25:11,26:$V6,27:$V7,28:$V8,29:$V9,35:$Va,36:$Vb},{4:50,7:$V0,8:$V1,18:5,19:$V2,22:$V3,23:$V4,24:$V5,25:11,26:$V6,27:$V7,28:$V8,29:$V9,35:$Va,36:$Vb},{4:51,7:$V0,8:$V1,18:5,19:$V2,22:$V3,23:$V4,24:$V5,25:11,26:$V6,27:$V7,28:$V8,29:$V9,35:$Va,36:$Vb},{4:52,7:$V0,8:$V1,18:5,19:$V2,22:$V3,23:$V4,24:$V5,25:11,26:$V6,27:$V7,28:$V8,29:$V9,35:$Va,36:$Vb},{4:53,7:$V0,8:$V1,18:5,19:$V2,22:$V3,23:$V4,24:$V5,25:11,26:$V6,27:$V7,28:$V8,29:$V9,35:$Va,36:$Vb},{4:54,7:$V0,8:$V1,18:5,19:$V2,22:$V3,23:$V4,24:$V5,25:11,26:$V6,27:$V7,28:$V8,29:$V9,35:$Va,36:$Vb},{4:55,7:$V0,8:$V1,18:5,19:$V2,22:$V3,23:$V4,24:$V5,25:11,26:$V6,27:$V7,28:$V8,29:$V9,35:$Va,36:$Vb},{5:[1,56],6:$Vc,7:$Vd,8:$Ve,9:$Vf,10:$Vg,11:$Vh,12:$Vi,13:$Vj,14:$Vk,15:$Vl,16:$Vm,17:$Vn,21:$Vo},o($Vq,[2,14],{9:$Vf,10:$Vg,11:$Vh,21:$Vo}),{4:57,7:$V0,8:$V1,18:5,19:$V2,22:$V3,23:$V4,24:$V5,25:11,26:$V6,27:$V7,28:$V8,29:$V9,35:$Va,36:$Vb},o($Vp,[2,17]),{6:$Vc,7:$Vd,8:$Ve,9:$Vf,10:$Vg,11:$Vh,12:$Vi,13:$Vj,14:$Vk,15:$Vl,16:$Vm,17:$Vn,20:[1,58],21:$Vo},o($Vp,[2,21]),o($Vp,[2,23]),o($Vp,[2,29]),{4:42,7:$V0,8:$V1,18:5,19:$V2,20:[1,60],22:$V3,23:$V4,24:$V5,25:11,26:$V6,27:$V7,28:$V8,29:$V9,32:59,35:$Va,36:$Vb},{33:$Vr,34:$Vs,37:[1,61]},o($Vt,[2,32],{6:$Vc,7:$Vd,8:$Ve,9:$Vf,10:$Vg,11:$Vh,12:$Vi,13:$Vj,14:$Vk,15:$Vl,16:$Vm,17:$Vn,21:$Vo}),o($Vq,[2,3],{9:$Vf,10:$Vg,11:$Vh,21:$Vo}),o($Vq,[2,4],{9:$Vf,10:$Vg,11:$Vh,21:$Vo}),o($Vu,[2,5],{11:$Vh,21:$Vo}),o($Vu,[2,6],{11:$Vh,21:$Vo}),o([5,6,7,8,9,10,11,12,13,14,15,16,17,20,33,34,37],[2,7],{21:$Vo}),o($Vv,[2,8],{7:$Vd,8:$Ve,9:$Vf,10:$Vg,11:$Vh,17:$Vn,21:$Vo}),o($Vv,[2,9],{7:$Vd,8:$Ve,9:$Vf,10:$Vg,11:$Vh,17:$Vn,21:$Vo}),o($Vv,[2,10],{7:$Vd,8:$Ve,9:$Vf,10:$Vg,11:$Vh,17:$Vn,21:$Vo}),o($Vv,[2,11],{7:$Vd,8:$Ve,9:$Vf,10:$Vg,11:$Vh,17:$Vn,21:$Vo}),o($Vv,[2,12],{7:$Vd,8:$Ve,9:$Vf,10:$Vg,11:$Vh,17:$Vn,21:$Vo}),o($Vv,[2,13],{7:$Vd,8:$Ve,9:$Vf,10:$Vg,11:$Vh,17:$Vn,21:$Vo}),o($Vw,[2,15],{7:$Vd,8:$Ve,9:$Vf,10:$Vg,11:$Vh,21:$Vo}),o($Vp,[2,19]),{1:[2,2]},o($Vw,[2,16],{7:$Vd,8:$Ve,9:$Vf,10:$Vg,11:$Vh,21:$Vo}),o($Vp,[2,18]),{20:[1,64],33:$Vr,34:$Vs},o($Vp,[2,36]),o($Vp,[2,37]),{4:65,7:$V0,8:$V1,18:5,19:$V2,22:$V3,23:$V4,24:$V5,25:11,26:$V6,27:$V7,28:$V8,29:$V9,35:$Va,36:$Vb},{4:42,7:$V0,8:$V1,18:5,19:$V2,22:$V3,23:$V4,24:$V5,25:11,26:$V6,27:$V7,28:$V8,29:$V9,32:66,35:$Va,36:$Vb},o($Vp,[2,35]),o($Vt,[2,33],{6:$Vc,7:$Vd,8:$Ve,9:$Vf,10:$Vg,11:$Vh,12:$Vi,13:$Vj,14:$Vk,15:$Vl,16:$Vm,17:$Vn,21:$Vo}),o([20,37],[2,34],{33:$Vr,34:$Vs})],
     defaultActions: {18:[2,1],56:[2,2]},
     parseError: function parseError(str, hash) {
         if (hash.recoverable) {
             this.trace(str);
         } else {
             throw new Error(str);
         }
     },
     parse: function parse(input) {
         var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
         var args = lstack.slice.call(arguments, 1);
         var lexer = Object.create(this.lexer);
         var sharedState = { yy: {} };
         for (var k in this.yy) {
             if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
                 sharedState.yy[k] = this.yy[k];
             }
         }
         lexer.setInput(input, sharedState.yy);
         sharedState.yy.lexer = lexer;
         sharedState.yy.parser = this;
         if (typeof lexer.yylloc == 'undefined') {
             lexer.yylloc = {};
         }
         var yyloc = lexer.yylloc;
         lstack.push(yyloc);
         var ranges = lexer.options && lexer.options.ranges;
         if (typeof sharedState.yy.parseError === 'function') {
             this.parseError = sharedState.yy.parseError;
         } else {
             this.parseError = Object.getPrototypeOf(this).parseError;
         }
         function popStack(n) {
             stack.length = stack.length - 2 * n;
             vstack.length = vstack.length - n;
             lstack.length = lstack.length - n;
         }
         _token_stack:
             function lex() {
                 var token;
                 token = lexer.lex() || EOF;
                 if (typeof token !== 'number') {
                     token = self.symbols_[token] || token;
                 }
                 return token;
             }
         var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
         while (true) {
             state = stack[stack.length - 1];
             if (this.defaultActions[state]) {
                 action = this.defaultActions[state];
             } else {
                 if (symbol === null || typeof symbol == 'undefined') {
                     symbol = lex();
                 }
                 action = table[state] && table[state][symbol];
             }
                         if (typeof action === 'undefined' || !action.length || !action[0]) {
                     var errStr = '';
                     expected = [];
                     for (p in table[state]) {
                         if (this.terminals_[p] && p > TERROR) {
                             expected.push('\'' + this.terminals_[p] + '\'');
                         }
                     }
                     if (lexer.showPosition) {
                         errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
                     } else {
                         errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
                     }
                     this.parseError(errStr, {
                         text: lexer.match,
                         token: this.terminals_[symbol] || symbol,
                         line: lexer.yylineno,
                         loc: yyloc,
                         expected: expected
                     });
                 }
             if (action[0] instanceof Array && action.length > 1) {
                 throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
             }
             switch (action[0]) {
             case 1:
                 stack.push(symbol);
                 vstack.push(lexer.yytext);
                 lstack.push(lexer.yylloc);
                 stack.push(action[1]);
                 symbol = null;
                 if (!preErrorSymbol) {
                     yyleng = lexer.yyleng;
                     yytext = lexer.yytext;
                     yylineno = lexer.yylineno;
                     yyloc = lexer.yylloc;
                     if (recovering > 0) {
                         recovering--;
                     }
                 } else {
                     symbol = preErrorSymbol;
                     preErrorSymbol = null;
                 }
                 break;
             case 2:
                 len = this.productions_[action[1]][1];
                 yyval.$ = vstack[vstack.length - len];
                 yyval._$ = {
                     first_line: lstack[lstack.length - (len || 1)].first_line,
                     last_line: lstack[lstack.length - 1].last_line,
                     first_column: lstack[lstack.length - (len || 1)].first_column,
                     last_column: lstack[lstack.length - 1].last_column
                 };
                 if (ranges) {
                     yyval._$.range = [
                         lstack[lstack.length - (len || 1)].range[0],
                         lstack[lstack.length - 1].range[1]
                     ];
                 }
                 r = this.performAction.apply(yyval, [
                     yytext,
                     yyleng,
                     yylineno,
                     sharedState.yy,
                     action[1],
                     vstack,
                     lstack
                 ].concat(args));
                 if (typeof r !== 'undefined') {
                     return r;
                 }
                 if (len) {
                     stack = stack.slice(0, -1 * len * 2);
                     vstack = vstack.slice(0, -1 * len);
                     lstack = lstack.slice(0, -1 * len);
                 }
                 stack.push(this.productions_[action[1]][0]);
                 vstack.push(yyval.$);
                 lstack.push(yyval._$);
                 newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
                 stack.push(newState);
                 break;
             case 3:
                 return true;
             }
         }
         return true;
     }};
     /* generated by jison-lex 0.3.4 */
     var lexer = (function(){
     var lexer = ({

     EOF:1,

     parseError:function parseError(str, hash) {
             if (this.yy.parser) {
                 this.yy.parser.parseError(str, hash);
             } else {
                 throw new Error(str);
             }
         },

     // resets the lexer, sets new input
     setInput:function (input, yy) {
             this.yy = yy || this.yy || {};
             this._input = input;
             this._more = this._backtrack = this.done = false;
             this.yylineno = this.yyleng = 0;
             this.yytext = this.matched = this.match = '';
             this.conditionStack = ['INITIAL'];
             this.yylloc = {
                 first_line: 1,
                 first_column: 0,
                 last_line: 1,
                 last_column: 0
             };
             if (this.options.ranges) {
                 this.yylloc.range = [0,0];
             }
             this.offset = 0;
             return this;
         },

     // consumes and returns one char from the input
     input:function () {
             var ch = this._input[0];
             this.yytext += ch;
             this.yyleng++;
             this.offset++;
             this.match += ch;
             this.matched += ch;
             var lines = ch.match(/(?:\r\n?|\n).*/g);
             if (lines) {
                 this.yylineno++;
                 this.yylloc.last_line++;
             } else {
                 this.yylloc.last_column++;
             }
             if (this.options.ranges) {
                 this.yylloc.range[1]++;
             }

             this._input = this._input.slice(1);
             return ch;
         },

     // unshifts one char (or a string) into the input
     unput:function (ch) {
             var len = ch.length;
             var lines = ch.split(/(?:\r\n?|\n)/g);

             this._input = ch + this._input;
             this.yytext = this.yytext.substr(0, this.yytext.length - len);
             //this.yyleng -= len;
             this.offset -= len;
             var oldLines = this.match.split(/(?:\r\n?|\n)/g);
             this.match = this.match.substr(0, this.match.length - 1);
             this.matched = this.matched.substr(0, this.matched.length - 1);

             if (lines.length - 1) {
                 this.yylineno -= lines.length - 1;
             }
             var r = this.yylloc.range;

             this.yylloc = {
                 first_line: this.yylloc.first_line,
                 last_line: this.yylineno + 1,
                 first_column: this.yylloc.first_column,
                 last_column: lines ?
                     (lines.length === oldLines.length ? this.yylloc.first_column : 0)
                      + oldLines[oldLines.length - lines.length].length - lines[0].length :
                   this.yylloc.first_column - len
             };

             if (this.options.ranges) {
                 this.yylloc.range = [r[0], r[0] + this.yyleng - len];
             }
             this.yyleng = this.yytext.length;
             return this;
         },

     // When called from action, caches matched text and appends it on next action
     more:function () {
             this._more = true;
             return this;
         },

     // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
     reject:function () {
             if (this.options.backtrack_lexer) {
                 this._backtrack = true;
             } else {
                 return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
                     text: "",
                     token: null,
                     line: this.yylineno
                 });

             }
             return this;
         },

     // retain first n characters of the match
     less:function (n) {
             this.unput(this.match.slice(n));
         },

     // displays already matched input, i.e. for error messages
     pastInput:function () {
             var past = this.matched.substr(0, this.matched.length - this.match.length);
             return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
         },

     // displays upcoming input, i.e. for error messages
     upcomingInput:function () {
             var next = this.match;
             if (next.length < 20) {
                 next += this._input.substr(0, 20-next.length);
             }
             return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
         },

     // displays the character position where the lexing error occurred, i.e. for error messages
     showPosition:function () {
             var pre = this.pastInput();
             var c = new Array(pre.length + 1).join("-");
             return pre + this.upcomingInput() + "\n" + c + "^";
         },

     // test the lexed token: return FALSE when not a match, otherwise return token
     test_match:function (match, indexed_rule) {
             var token,
                 lines,
                 backup;

             if (this.options.backtrack_lexer) {
                 // save context
                 backup = {
                     yylineno: this.yylineno,
                     yylloc: {
                         first_line: this.yylloc.first_line,
                         last_line: this.last_line,
                         first_column: this.yylloc.first_column,
                         last_column: this.yylloc.last_column
                     },
                     yytext: this.yytext,
                     match: this.match,
                     matches: this.matches,
                     matched: this.matched,
                     yyleng: this.yyleng,
                     offset: this.offset,
                     _more: this._more,
                     _input: this._input,
                     yy: this.yy,
                     conditionStack: this.conditionStack.slice(0),
                     done: this.done
                 };
                 if (this.options.ranges) {
                     backup.yylloc.range = this.yylloc.range.slice(0);
                 }
             }

             lines = match[0].match(/(?:\r\n?|\n).*/g);
             if (lines) {
                 this.yylineno += lines.length;
             }
             this.yylloc = {
                 first_line: this.yylloc.last_line,
                 last_line: this.yylineno + 1,
                 first_column: this.yylloc.last_column,
                 last_column: lines ?
                              lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length :
                              this.yylloc.last_column + match[0].length
             };
             this.yytext += match[0];
             this.match += match[0];
             this.matches = match;
             this.yyleng = this.yytext.length;
             if (this.options.ranges) {
                 this.yylloc.range = [this.offset, this.offset += this.yyleng];
             }
             this._more = false;
             this._backtrack = false;
             this._input = this._input.slice(match[0].length);
             this.matched += match[0];
             token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
             if (this.done && this._input) {
                 this.done = false;
             }
             if (token) {
                 return token;
             } else if (this._backtrack) {
                 // recover context
                 for (var k in backup) {
                     this[k] = backup[k];
                 }
                 return false; // rule action called reject() implying the next rule should be tested instead.
             }
             return false;
         },

     // return next match in input
     next:function () {
             if (this.done) {
                 return this.EOF;
             }
             if (!this._input) {
                 this.done = true;
             }

             var token,
                 match,
                 tempMatch,
                 index;
             if (!this._more) {
                 this.yytext = '';
                 this.match = '';
             }
             var rules = this._currentRules();
             for (var i = 0; i < rules.length; i++) {
                 tempMatch = this._input.match(this.rules[rules[i]]);
                 if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                     match = tempMatch;
                     index = i;
                     if (this.options.backtrack_lexer) {
                         token = this.test_match(tempMatch, rules[i]);
                         if (token !== false) {
                             return token;
                         } else if (this._backtrack) {
                             match = false;
                             continue; // rule action called reject() implying a rule MISmatch.
                         } else {
                             // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                             return false;
                         }
                     } else if (!this.options.flex) {
                         break;
                     }
                 }
             }
             if (match) {
                 token = this.test_match(match, rules[index]);
                 if (token !== false) {
                     return token;
                 }
                 // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                 return false;
             }
             if (this._input === "") {
                 return this.EOF;
             } else {
                 return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                     text: "",
                     token: null,
                     line: this.yylineno
                 });
             }
         },

     // return next match that has a token
     lex:function lex() {
             var r = this.next();
             if (r) {
                 return r;
             } else {
                 return this.lex();
             }
         },

     // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
     begin:function begin(condition) {
             this.conditionStack.push(condition);
         },

     // pop the previously active lexer condition state off the condition stack
     popState:function popState() {
             var n = this.conditionStack.length - 1;
             if (n > 0) {
                 return this.conditionStack.pop();
             } else {
                 return this.conditionStack[0];
             }
         },

     // produce the lexer rule set which is active for the currently active lexer condition state
     _currentRules:function _currentRules() {
             if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
                 return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
             } else {
                 return this.conditions["INITIAL"].rules;
             }
         },

     // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
     topState:function topState(n) {
             n = this.conditionStack.length - 1 - Math.abs(n || 0);
             if (n >= 0) {
                 return this.conditionStack[n];
             } else {
                 return "INITIAL";
             }
         },

     // alias for begin(condition)
     pushState:function pushState(condition) {
             this.begin(condition);
         },

     // return the number of states currently on the stack
     stateStackSize:function stateStackSize() {
             return this.conditionStack.length;
         },
     options: {},
     performAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {
     var YYSTATE=YY_START;
     switch($avoiding_name_collisions) {
     case 0:/* skip whitespace */
     break;
     case 1:return 29
     break;
     case 2:return 26
     break;
     case 3:return 27
     break;
     case 4:return 9
     break;
     case 5:return 10
     break;
     case 6:return 8
     break;
     case 7:return 7
     break;
     case 8:return 17
     break;
     case 9:return 11
     break;
     case 10:return 19
     break;
     case 11:return 20
     break;
     case 12:return ">="
     break;
     case 13:return "<="
     break;
     case 14:return "<>"
     break;
     case 15:return "="
     break;
     case 16:return ">"
     break;
     case 17:return "<"
     break;
     case 18:return "{"
     break;
     case 19:return "}"
     break;
     case 20:return "!"
     break;
     case 21:return ","
     break;
     case 22:return ":"
     break;
     case 23:return ";"
     break;
     case 24:return "%"
     break;
     case 25:return 35;
     break;
     case 26:return 35;
     break;
     case 27:yy_.yytext = yy_.yytext.substr(2,yy_.yyleng-3).replace(/\"\"/g, "\""); return "SHEET";
     break;
     case 28:yy_.yytext = yy_.yytext.substr(1,yy_.yyleng-3).replace(/\"\"/g, "\""); return "SHEET";
     break;
     case 29:yy_.yytext = yy_.yytext.slice(0, -1); return "SHEET"
     break;
     case 30:yy_.yytext = yy_.yytext.slice(1, -1); return "SHEET"
     break;
     case 31:return "CELL";
     break;
     case 32:yy_.yytext = yy_.yytext.substr(1,yy_.yyleng-2).replace(/\"\"/g, "\""); return "STRING";
     break;
     case 33:return 24
     break;
     case 34:return 5
     break;
     case 35:return 'INVALID'
     break;
     }
     },
     rules: [/^(?:\s+)/,/^(?:[0-9]+(\.[0-9]+)?\b)/,/^(?:TRUE\b)/,/^(?:FALSE\b)/,/^(?:\*)/,/^(?:\/)/,/^(?:-)/,/^(?:\+)/,/^(?:&)/,/^(?:\^)/,/^(?:\()/,/^(?:\))/,/^(?:>=)/,/^(?:<=)/,/^(?:<>)/,/^(?:=)/,/^(?:>)/,/^(?:<)/,/^(?:\{)/,/^(?:\})/,/^(?:!)/,/^(?:,)/,/^(?::)/,/^(?:;)/,/^(?:%)/,/^(?:[A-Za-z](?=[(]))/,/^(?:[A-Za-z][A-Za-z0-9\.]+(?=[(]))/,/^(?:\$'(?:''|[^'])*'!)/,/^(?:'(?:''|[^'])*'!)/,/^(?:[a-zA-Z]([a-zA-Z0-9.$]+)?!)/,/^(?:\$([a-zA-Z])([a-zA-Z0-9.$]+)?!)/,/^(?:\$?([a-zA-Z]+)\$?([0-9]+))/,/^(?:"(?:""|[^"])*")/,/^(?:[a-zA-Z]([a-zA-Z0-9.$^\(]+)?)/,/^(?:$)/,/^(?:.)/],
     conditions: {"INITIAL":{"rules":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35],"inclusive":true}}
     });
     return lexer;
     })();
     parser.lexer = lexer;
     function Parser () {
       this.yy = {};
     }
     Parser.prototype = parser;parser.Parser = Parser;
     return new Parser;
     })();
   #+END_SRC

* Workbook.js Code 						   :noexport:
  
   The complete script including common routine and routines to load intermediate files.
  
   #+BEGIN_SRC js :noweb yes :tangle workbook.js :exports none
      /* 
         Workbook (1.0.0)
         ==

         Copyright 2014 Peter W Moresi

         License: GPLv2

         Portions from formula.js Copyright (c) 2014 Sutoiku, Inc. (see LICENSE file)
         
         Portions from SocialCalc Copyright (C) 2009 Socialtext, Inc. (see LICENSE file)
      ,*/

      ;(function(root) {

          var fn, // a container for functions used by spreadsheet formula
              error,
              //See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)
              MAX_SAFE_INTEGER = (Math.pow(2, 53) - 1),
              MAX_COLS = 16384,   // 14 bits, 2^14
              MAX_ROWS = 1048576, // 20 bits, 2^20

              /*
               The cell index tracks a rows and cols with a single number.
               
               The cell index is a value between 0 and 17179869183.

               The max value is the binary number '1111111111111111111111111111111111'.

               The first 20 bits from left-to-right is the row index; from 0...MAX_ROWS-1.
               
               The remaining 14 bits are the column index; from 0...MAX_COLS-1.

               Unfortunately, since JavaScript doesn't have an unsigned shift left I was
               forced to resort to multiplication which is less efficient but will have
               to do.

               Mapping the row/col efficiently to an array is the key to the money.
              ,*/
              CELLINDEX = function(row, col) { return (Math.floor((row) * MAX_COLS) + (col)); },
              INDEX2ADDR = function(index) { var row = INDEX2ROW(index); return { rowIndex: row, colIndex: index - (row * MAX_COLS) }; },
              INDEX2COL = function(index) { return index - (INDEX2ROW(index) * MAX_COLS); },
              INDEX2ROW = function(index) { return Math.floor(index / MAX_COLS); }

              compiledNumber = 0,
              
              // Date Constants
              d1900 = new Date(1900, 0, 1),
              JulianOffset = 2415019,
              MinutesInHour = 60,
              MinutesInDay = 1440,
              SecondsInMinute = 60,
              SecondsInHour = 3600,
              SecondsInDay = 86400,
              DaysInYear = 365.25,
              MilliSecondsInDay = 86400000,

              // Format Constants
              SeparatorChar = ",",
              DecimalChar = ".",
              DefaultCurrency = "$", // the currency string used if none specified
              AllowedColors = {
                  BLACK: "#000000", BLUE: "#0000FF", CYAN: "#00FFFF",
                  GREEN: "#00FF00", MAGENTA: "#FF00FF", RED: "#FF0000",
                  WHITE: "#FFFFFF", YELLOW: "#FFFF00"},
              AllowedDates = {H: "h]", M: "m]", MM: "mm]", S: "s]", SS: "ss]"},
              DayNames = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
              DayNames3 = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
              MonthNames = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
              MonthNames3 = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
              AM = "AM",
              AM1 = "A",
              PM = "PM",
              PM1 = "P";


          <<FormulaParser>>

          //////////// FORMULA PARSER ////////////////////////////////////
          if (!parser) { throw Error("Parser is not loaded."); }

          // Calculation Errors
          <<CalcErrors>>

          // Cell Model
          <<CellModel>>

          // Range Model
          <<RangeModel>>
              
          // Workbook Model
          <<WorkbookModel>>
              
          // Built-in Functions
          <<Functions>>         
          
          // Handle compatibility with Node.js
          if (typeof module !== 'undefined' && module.exports) {
              exports = module.exports = workbook;
          }

          // AMD registration happens at the end for compatibility with AMD loaders
          // that may not enforce next-turn semantics on modules. Even though general
          // practice for AMD registration is to be anonymous, underscore registers
          // as a named module because, like jQuery, it is a base library that is
          // popular enough to be bundled in a third party lib, but not be part of
          // an AMD load request. Those cases could generate an error when an
          // anonymous define() is called outside of a loader request.
          if (typeof define === 'function' && define.amd) {
              define('formula', [], function() {
                  return workbook;
              });
          }

          // Web Workers
          if (typeof importScripts === 'function') {
              workbook.onmessage = function (oEvent) {
                  
                  var req = oEvent.data;
                  
                  switch(req.command) {
                  case "start":
                  case "load-workbook":
                      workbook.Current = new workbook(req.config);

                      postMessage({ req: req, res: "sucess" });
                      return;
                  case "create-worksheet": 
                      var ws = workbook.Current.sheet(req.config);


                      ws.on("set", function(addr, newValue, oldValue) {
                          postMessage({
                              command: "set",
                              res: {
                                  worksheet: this.name,
                                  addr: addr,
                                  newValue: newValue,
                                  oldValue: oldValue
                              }
                          });
                      });

                      ws.on("updated", function(addr, newValue, oldValue) {
                          postMessage({
                              command: "updated",
                              res: {
                                  worksheet: this.name,
                                  addr: addr,
                                  newValue: newValue,
                                  oldValue: oldValue
                              }
                          });
                      });
                      
                      postMessage({ req: req, res: "sucess" });
                      return;
                  case "set":
                      var result = workbook.Current.get(req.worksheet).set(req.ref, req.value).get(req.ref);
                      postMessage({ req: req, res: "sucess" });
                      return;
                  case "get":
                      var result = workbook.Current.get(req.worksheet).get(req.ref);
                      if (fn.ISCELL(result)) {
                          result = { addr: result.addr(), worksheet: result.worksheet.name, value: result.valueOf() }
                      }
                      postMessage({ req: req, res: result });
                      return;
                  case "run":
                      var result = workbook.Current.get(req.worksheet).run(req.fn);
                      if (fn.ISCELL(result)) {
                          result = { addr: result.addr(), worksheet: result.worksheet.name, value: result.valueOf() }
                      }
                      postMessage({ req: req, res: result });         
                      return;
                  case "name":
                      var result = workbook.Current.get(req.worksheet).nameRange(req.name, req.ref);
                      postMessage({ req: req, res: result });
                      return;
                  }
                  
                  postMessage("unknown request");
                  
              };

              onmessage = workbook.onmessage;
          }


          return workbook;

      })(this);
   #+END_SRC

* About This Document						   :noexport:

  This is a plain text database in org-mode format.

  This project is an experiment in Literate Programming to create a Workbook model that will rule the financial web for the next 30 years.
